<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width" />
  <script
    type="application/javascript"
    src='https://rvnox.github.io/js/theme-mode.js'
  ></script>
  <link rel="stylesheet" href='https://rvnox.github.io/css/frameworks.min.css' />
  <link rel="stylesheet" href='https://rvnox.github.io/css/github.min.css' />
  <link rel="stylesheet" href='https://rvnox.github.io/css/github-style.css' />
  <link rel="stylesheet" href='https://rvnox.github.io/css/light.css' />
  <link rel="stylesheet" href='https://rvnox.github.io/css/dark.css' />
  <link rel="stylesheet" href='https://rvnox.github.io/css/syntax.css' />
  
  <link rel="stylesheet" href="/custom.css" />
  
  <title>
    Golang 入门到入土（基础语法） | rvnox&#39;s Blog
  </title>
  
  <link rel="icon" type="image/x-icon" href="/images/github-mark.png" />
  
  <meta name="theme-color" content="#1e2327" />

  
  <meta
  name="description"
  content="Golang 基础语法&#43;demo，适合快速入门和回顾基础知识"
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://rvnox.github.io/post/2025-0331-01/" />


<meta name="twitter:card" content="summary" />
<meta
  name="twitter:title"
  content="Golang 入门到入土（基础语法） - rvnox&#39;s Blog"
/>
<meta
  name="twitter:description"
  content="Golang 基础语法&#43;demo，适合快速入门和回顾基础知识"
/>
<meta name="twitter:site" content="https://rvnox.github.io/" />
<meta name="twitter:creator" content="" />
<meta
  name="twitter:image"
  content="https://rvnox.github.io/"
/>


<meta
  property="og:type"
  content="article"
/>
<meta
  property="og:title"
  content="Golang 入门到入土（基础语法） - rvnox&#39;s Blog"
/>
<meta
  property="og:description"
  content="Golang 基础语法&#43;demo，适合快速入门和回顾基础知识"
/>
<meta property="og:url" content="https://rvnox.github.io/post/2025-0331-01/" />
<meta property="og:site_name" content="Golang 入门到入土（基础语法）" />
<meta
  property="og:image"
  content="https://rvnox.github.io/"
/>
<meta property="og:image:width" content="2048" />
<meta property="og:image:height" content="1024" />

<meta property="article:published_time" content="2025-03-31 20:14:01 &#43;0800 &#43;0800" />















</head>


<script src="/js/pangu.js"></script>

<script>
	document.addEventListener('DOMContentLoaded', () => {
			pangu.autoSpacingPage();
	});
</script>

<body>
  

<style>
  .height-limitation {
    max-height: 300px;
    overflow-y: scroll;
  }

  .loader {
    border: 4px solid #f3f3f3;
    border-bottom: 4px solid var(--color-fg-muted);
    border-radius: 50%;
    width: 30px;
    height: 30px;
    animation: spin 1s linear infinite;
    margin: 0 auto;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
</style>

<div style="position: relative">
  <header
    class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on"
  >
    <div
      class="Header-item mobile-none"
      style="margin-top: -4px; margin-bottom: -4px"
    >
      <a class="Header-link" href="https://rvnox.github.io/" aria-label="Home">
        <svg
          class="octicon"
          height="32"
          viewBox="0 0 16 16"
          version="1.1"
          width="32"
        >
          <path
            fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
          ></path>
        </svg>
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button
        class="Header-link btn-link js-details-target"
        type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'"
        aria-label="Search"
      >
        <svg
          height="24"
          class="octicon octicon-three-bars"
          viewBox="0 0 16 16"
          version="1.1"
          width="24"
        >
          <path
            fill-rule="evenodd"
            d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z"
          ></path>
        </svg>
      </button>
    </div>
    <div
      style="display: none"
      id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex"
    >
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to"
      >
        <div class="position-relative">
          <form
            target="_blank"
            action="https://www.google.com/search"
            accept-charset="UTF-8"
            method="get"
            autocomplete="off"
          >
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center"
            >
              <input
                type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q"
                value=""
                placeholder="Search"
                autocomplete="off"
              />
              <input type="hidden" name="q" value="site:https://rvnox.github.io/" />
              <div
                class="js-jump-to-suggestions-container jump-to-suggestions overflow-hidden position-absolute"
              >
                <div
                  id="search-progress"
                  class="d-none color-bg-primary no-underline p-2"
                  role="progress"
                  aria-selected="false"
                >
                  <div class="loader"></div>
                </div>

                <ul
                  id="jump-to-results"
                  role="listbox"
                  class="Box border-0 p-0 m-0 js-navigation-container jump-to-suggestions-results-container js-jump-to-suggestions-results-container js-active-navigation-container height-limitation"
                ></ul>
              </div>
            </label>
          </form>
        </div>
      </div>
    </div>

    <div
      class="Header-item Header-item--full flex-justify-center d-md-none position-relative"
    >
      <a class="Header-link" href="https://rvnox.github.io/" aria-label="Home">
        <svg
          class="octicon octicon-mark-github v-align-middle"
          height="32"
          viewBox="0 0 16 16"
          version="1.1"
          width="32"
        >
          <path
            fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
          ></path>
        </svg>
      </a>
    </div>
    <div class="Theme-switcher Header-item" style="margin-right: 0">
      <span
        role="button"
        class="Header-link no-select"
        onclick="switchTheme()"
        style="cursor: pointer"
        aria-label="Switch theme"
      >
        <svg
          style="fill: var(--color-profile-color-modes-toggle-moon)"
          class="no-select"
          viewBox="0 0 16 16"
          version="1.1"
          width="16"
          height="16"
        >
          <path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z"
          ></path>
        </svg>
      </span>
    </div>
  </header>
</div>

  
<script type="text/javascript" src="/js/initimage.js"></script>



<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://rvnox.github.io/">
                  <img class=" avatar-user"
                    src="/images/avatar.png"
                    width="32" height="32" alt="κόραξ"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://rvnox.github.io/">κόραξ</a></span><span
                    class="path-divider">/</span><strong class="css-truncate-target mr-1" style="max-width: 410px"><a
                      href="https://rvnox.github.io/post/2025-0331-01/">Golang 入门到入土（基础语法）</a></strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Mon, 31 Mar 2025 20:14:01 &#43;0800"
                    class="no-wrap">
                    Mon, 31 Mar 2025 20:14:01 &#43;0800</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Fri, 15 Aug 2025 13:50:32 &#43;0000"
                    class="no-wrap">
                    Fri, 15 Aug 2025 13:50:32 &#43;0000</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      54747 Words
                    <span class="file-info-divider"></span>
                                        249 min

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
  
    
       
       
       
       
      
      
      
        
       
      <a class="muted-link mr-3" href="/tags/golang">
        <span class="repo-language-color" style="background-color: #6564c5"></span>
        Golang
      </a>
    
  

                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><p>参考：https://www.liwenzhou.com/posts/Go/golang-menu/（感谢大佬！）</p>
<h1 id="变量和常量">变量和常量</h1>
<p>变量和常量在任何编程语言中都必不可少</p>
<h2 id="标识符与关键字">标识符与关键字</h2>
<blockquote>
<p><strong>标识符</strong></p>
</blockquote>
<p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code></p>
<blockquote>
<p><strong>关键字</strong></p>
</blockquote>
<p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p>
<p>Go语言中有25个关键字：</p>
<pre tabindex="0"><code>    break        default      func         interface    select
    case         defer        go           map          struct
    chan         else         goto         package      switch
    const        fallthrough  if           range        type
    continue     for          import       return       var
</code></pre><p>此外，Go语言中还有37个保留字。</p>
<pre tabindex="0"><code>    Constants:    true  false  iota  nil

        Types:    int  int8  int16  int32  int64  
                  uint  uint8  uint16  uint32  uint64  uintptr
                  float32  float64  complex128  complex64
                  bool  byte  rune  string  error

    Functions:   make  len  cap  new  append  copy  close  delete
                 complex  real  imag
                 panic  recover
</code></pre><h2 id="变量">变量</h2>
<p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p>
<p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p>
<h3 id="变量声明">变量声明</h3>
<p>Golang 语言的变量声明比较灵活，它支持多种变量声明的方式。</p>
<blockquote>
<p><strong>1、标准声明变量</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">100</span>
</span></span></code></pre></div><p>Golang 语言的标准声明变量方式包含 4 部分，分别是 var 关键字，变量名 a，变量类型 int 和变量的值 100。</p>
<blockquote>
<p><strong>2、不显式赋初始值声明变量</strong></p>
</blockquote>
<p>如果我们不想给声明的变量赋初始值，也可以不显式给变量赋值，省略等号和值，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span>
</span></span></code></pre></div><p>如果不显式给变量赋值，变量的值是类型的零值，即类型的默认值。</p>
<blockquote>
<p><strong>3、短变量声明</strong></p>
</blockquote>
<p>标准声明变量方式的 4 部分，除了可以不显式给变量赋值，还可以省略类型，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">100</span>
</span></span></code></pre></div><blockquote>
<p><strong>4、短变量声明</strong></p>
</blockquote>
<p>Golang 语言还有一种最简化的声明变量的方式，短变量声明，使用短变量声明的方式，可以同时省略关键字 var 和变量的类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="mi">100</span>
</span></span></code></pre></div><p>短变量声明的这种方式是存在一定的局限性的，它只能用于局部变量声明。</p>
<h3 id="变量列表声明">变量列表声明</h3>
<p>所有声明变量的方式，都支持变量列表声明。所谓变量列表声明，就是使用 var 关键字，通过一行代码声明多个变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">f</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">g</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">400</span><span class="p">,</span> <span class="s">&#34;你好&#34;</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="nx">j</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">l</span> <span class="o">:=</span> <span class="mi">500</span><span class="p">,</span> <span class="s">&#34;世界&#34;</span><span class="p">,</span> <span class="mf">3.14</span>
</span></span></code></pre></div><h3 id="变量块声明">变量块声明</h3>
<p>Golang 语言还支持变量声明块，使用关键字 var 将多个单个变量声明或变量列表声明放在一起，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">c</span> <span class="p">=</span> <span class="mi">300</span>
</span></span><span class="line"><span class="cl">    <span class="nx">d</span> <span class="p">=</span> <span class="mf">3.14</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">e</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">g</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span>
</span></span><span class="line"><span class="cl">    <span class="nx">h</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">string</span> <span class="p">=</span> <span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><h3 id="局部变量--包级变量--全局变量">局部变量 | 包级变量 | 全局变量</h3>
<blockquote>
<p><strong>局部变量</strong></p>
</blockquote>
<p>局部变量的作用域是只能在函数体或方法体中使用。</p>
<p>局部变量，一般会优先使用短变量声明的方式，除非不想给局部变量显式初始化，我们可以使用省略类型声明变量的方式。</p>
<blockquote>
<p><strong>包级变量</strong></p>
</blockquote>
<p>包级变量的作用域是只能在同一个 package 中使用。</p>
<p>包级变量，只能使用 var 关键字的变量声明方式，如果变量声明显式初始化，一般会使用省略类型声明变量的方式。</p>
<blockquote>
<p><strong>全局变量</strong></p>
</blockquote>
<p>全局变量的作用域是在项目的任意位置都可以使用。</p>
<p>如果包级变量的变量名首字母大写，也就是 Golang 语言中的导出变量，那么这个变量就成为全局变量，可以在全局使用。</p>
<p>全局变量，也只能使用 var 关键字的变量声明方式，如果变量声明显式初始化，一般会使用省略类型声明变量的方式。</p>
<h3 id="匿名变量">匿名变量</h3>
<p>在多重赋值的时候，如果要忽略某些值，可以使用匿名变量，匿名变量用 _ 表示。</p>
<p>下划线（_）在 golang 中是一个特殊的标识符，被用作占位符。在不需要使用变量的地方，可以用来表示变量名，这样可以避免编译器报出未使用变量的警告，同时也表明了这个变量是不需要使用的。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#34;Q1mi&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;x=&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;y=&#34;</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="常量">常量</h2>
<p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。</p>
<h3 id="常量声明">常量声明</h3>
<p>常量的声明和变量声明非常类似，只是把 var 换成了 const，常量在定义的时候必须赋值</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">pi</span> <span class="p">=</span> <span class="mf">3.1415</span>
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">e</span> <span class="p">=</span> <span class="mf">2.7182</span>
</span></span></code></pre></div><p>定义了 pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p>
<p>多个常量也可以一起声明，每个常量的类型可以不同</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">x</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="nx">y</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">z</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="nx">b</span>
</span></span><span class="line"><span class="cl">  <span class="nx">c</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">  <span class="nx">d</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>上面示例中，常量 b 为1，c为2</p>
<h3 id="常量计数器-iota">常量计数器 iota</h3>
<p>iota 是 go 语言的常量计数器，只能在常量的表达式中使用，iota 可以认为是一个可以被编译器修改的常量。</p>
<p>iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次（iota可理解为const语句块中的行索引）。</p>
<p>使用iota能简化定义，在定义枚举时很有用。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Sunday</span> <span class="p">=</span> <span class="kc">iota</span> 	 <span class="c1">// iota 从 0 开始，每次递增 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Monday</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Tuesday</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Wednesday</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Thursday</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Friday</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Saturday</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">today</span> <span class="o">:=</span> <span class="nx">Wednesday</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;今天是：&#34;</span><span class="p">,</span> <span class="nx">today</span><span class="p">)</span>  		<span class="c1">// 今天是：3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>iota 的常用示例</strong></p>
</blockquote>
<p>使用 _ 跳过某些值</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n1</span> <span class="p">=</span> <span class="kc">iota</span> <span class="c1">//0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">n2</span>        <span class="c1">//1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">_</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n4</span>        <span class="c1">//3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">)</span>
</span></span></code></pre></div><p>iota声明中间插队</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n1</span> <span class="p">=</span> <span class="kc">iota</span> 	<span class="c1">//0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">n2</span> <span class="p">=</span> <span class="mi">100</span>  	<span class="c1">// 100（这里插队进行手动赋值，不影响 iota 计数）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">n3</span> <span class="p">=</span> <span class="kc">iota</span> 	<span class="c1">//2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">n4</span>        	<span class="c1">//3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">const</span> <span class="nx">n5</span> <span class="p">=</span> <span class="kc">iota</span> 	<span class="c1">//0（这里是一个新的 const 语句，iota 重新从 0 开始计数）
</span></span></span></code></pre></div><p>定义数量级</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_</span>  <span class="p">=</span> <span class="kc">iota</span>
</span></span><span class="line"><span class="cl">		<span class="nx">KB</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MB</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">GB</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">TB</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">PB</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span></code></pre></div><p>多个iota定义在一行</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">2</span>	<span class="c1">//1,2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">,</span> <span class="nx">d</span>		<span class="c1">//2,3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">e</span><span class="p">,</span> <span class="nx">f</span>		<span class="c1">//3,4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">)</span>
</span></span></code></pre></div><h1 id="数据类型">数据类型</h1>
<h2 id="类型分类">类型分类</h2>
<p>Go 语言按类别有以下几种数据类型：</p>
<p><img 
  src="./2025-0331-01/image-20250406120208329.png" 
  alt="image-20250406120208329" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250406120208329.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h2 id="值类型和引用类型">值类型和引用类型</h2>
<p>在 go 语言中，数据类型可以分为值类型和引用类型，理解这两种类型的区别对于理解 golang 中的数据传递和内存管理是很重要的。</p>
<p>在了解之前，我们得先区分个概念，值类型和引用类型<code>与</code>值传递和引用传递不是一个东西</p>
<p>数据类型分：值类型和引用类型</p>
<p>参数传递分：值传递和引用传递，<code>注意</code>：go 语言中都是值传递，没有引用传递。</p>
<blockquote>
<p><strong>Golang 的内存模型</strong></p>
</blockquote>
<p>Golang 在内存分配上有两个主要的区域：栈（stack）和堆（heap）。</p>
<p>栈用于存储函数调用时的局部变量和函数参数，特点是分配和回收速度快。而堆则用于存储那些可能需要跨函数存活的数据，由垃圾回收器管理。</p>
<blockquote>
<p><strong>值类型</strong></p>
</blockquote>
<p>值类型是指变量直接存储了实际的数据，并且每个变量都拥有独立的存储空间。当一个值类型的变量被赋给另一个变量时，会进行值拷贝，对其中一个变量的修改不会影响到原始变量。</p>
<p>在 Golang 中，值类型包括以下几种：</p>
<ul>
<li>基本数据类型：
<ul>
<li>整型（int、uint、int8等）、浮点型（float32、float64）、复数（complex64, complex128）、布尔型（bool）、字符串型（string）</li>
</ul>
</li>
<li>复合数据类型：
<ul>
<li>数组（array）、结构体（struct）</li>
</ul>
</li>
</ul>
<p>值类型有以下特点：</p>
<ul>
<li>直接存储值，不存储地址。</li>
<li>变量间赋值或作为函数参数传递时进行值复制。</li>
<li>值类型的变量副本是独立的，修改一个变量的副本不会影响另一个。</li>
<li>值类型的复制会涉及整个值的拷贝，因此对于大的结构体或数组，复制操作可能会较慢。</li>
<li>值类型通常在栈上分配，除非是通过 new 函数分配的，或者是作为闭包中的变量被分配到堆上。</li>
</ul>
<p>看一个简单的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">x</span> <span class="o">:=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">    <span class="nx">y</span> <span class="o">:=</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">    <span class="nx">x</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="c1">// 输出：11 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>在这个例子中，x 和 y 都是整型值，y 是 x 的一个副本。对 x 的修改不会影响到 y，因此 y 的值仍然是10。</p>
<blockquote>
<p><strong>引用类型</strong></p>
</blockquote>
<p>引用类型并不直接存储数据本身，而是存储指向数据的指针，当复制一个引用类型的变量时，复制的是指针，新旧变量将指向相同的底层数据。</p>
<p>在 Golang 中，引用类型主要包括：</p>
<ul>
<li>切片（Slices）：切片是对数组的封装，提供了一个灵活、动态的视图。当修改切片中的元素时，实际上是在修改底层数组的相应元素。</li>
<li>映射（Maps）：映射是一种存储键值对的集合。将映射传递给一个函数或者赋值给另一个变量时，任何对映射的修改都会反映在所有引用了这个映射的地方。</li>
<li>通道（Channels）：通道用于在不同的 goroutine 之间传递消息。通道本质上是引用类型，当复制或传递它们时，实际上传递的是对通道数据结构的引用。</li>
<li>接口（Interfaces）：接口类型是一种抽象类型，定义了一组方法，但不会实现这些方法。接口内部存储的是指向实现了接口方法的值的指针和指向该类型信息的指针。</li>
<li>函数（Functions）：在 Go 中，函数也是一种引用类型。当把一个函数赋给另一个变量时，实际上是在复制一个指向该函数的引用。</li>
<li>指针（Pointer）：指针类型是 Golang 中的一种基本类型，存储了值的内存地址。指针类型可以指向任何值类型的数据，并且通过指针，可以在不同的函数之间共享和修改数据。</li>
</ul>
<p>引用类型有以下特点：</p>
<ul>
<li>存储的是指向数据的地址，而不是数据本身。</li>
<li>当引用类型的变量被赋值或作为函数参数传递时，实际上是将该地址复制一份，因此多个变量可能共享同一份数据。</li>
<li>引用类型的数据通常在堆上分配，即使变量本身在栈上。</li>
<li>引用类型的零值是 nil，一个未初始化的引用类型的变量将会是 nil，不指向任何内存地址。</li>
</ul>
<p>看一个简单的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">modifySlice</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span> <span class="c1">// 对切片元素的修改会影响到原切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">numbers</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">modifySlice</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="c1">// 输出：[100 2 3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>值传递和引用传递</strong></p>
</blockquote>
<p>值传递：值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<p><strong>即：实参和形参 地址不一致</strong></p>
<p>引用传递：所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<p><strong>即：实参和形参 地址一致。</strong></p>
<p>在 go 语言中，没有引用传递的概念，只有值传递。即在Go中形参和实参的地址都是不同的。</p>
<p>但是由于数据类型的不同，通过修改形参可以改变实参。</p>
<p>同样是值传递，对于</p>
<ul>
<li>值类型：修改形参，实参不受影响，因为地址不一致。</li>
<li>引用类型：修改形参，实参随之改变，因为实参和形参都同时引用了相同的变量地址，或者说都指向了同一个变量地址。</li>
</ul>
<p>我们来看个实际例子，<code>值类型-&gt;数组</code>和<code>引用类型-&gt;切片</code>的区别：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">// 修改切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">modifySlice</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 修改数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">modifyArray</span><span class="p">(</span><span class="nx">a</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 原始切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">modifySlice</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;修改后切片:&#34;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span> <span class="c1">// =&gt; [100 2 3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 原始数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">array</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">modifyArray</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;修改后数组:&#34;</span><span class="p">,</span> <span class="nx">array</span><span class="p">)</span> <span class="c1">// =&gt; [1 2 3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h1 id="基础运算符">基础运算符</h1>
<h2 id="算数运算符">算数运算符</h2>
<p><img 
  src="./2025-0331-01/image-20250402194721985.png" 
  alt="image-20250402194721985" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250402194721985.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h2 id="关系运算符">关系运算符</h2>
<p><img 
  src="./2025-0331-01/image-20250402194822470.png" 
  alt="image-20250402194822470" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250402194822470.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p><img 
  src="./2025-0331-01/image-20250402194859602.png" 
  alt="image-20250402194859602" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250402194859602.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h2 id="位运算符">位运算符</h2>
<p><img 
  src="./2025-0331-01/image-20250402194955393.png" 
  alt="image-20250402194955393" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250402194955393.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h2 id="赋值运算符">赋值运算符</h2>
<p><img 
  src="./2025-0331-01/image-20250402195021038.png" 
  alt="image-20250402195021038" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250402195021038.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h1 id="流程控制">流程控制</h1>
<h2 id="if-else分支结构">if else（分支结构）</h2>
<blockquote>
<p><strong>if条件判断基本写法</strong></p>
</blockquote>
<p>Go语言中if条件判断的格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">表达式1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">分支1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">表达式2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">分支2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">分支3</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当表达式1的结果为true时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的else if和else都是可选的，可以根据实际需要进行选择。</p>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ifDemo1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">score</span> <span class="o">:=</span> <span class="mi">65</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">90</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">score</span> <span class="p">&gt;</span> <span class="mi">75</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;C&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>if条件判断特殊写法</strong></p>
</blockquote>
<p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ifDemo2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">score</span> <span class="o">:=</span> <span class="mi">65</span><span class="p">;</span> <span class="nx">score</span> <span class="o">&gt;=</span> <span class="mi">90</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">score</span> <span class="p">&gt;</span> <span class="mi">75</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;C&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="for循环结构">for（循环结构）</h2>
<p>Go 语言中的所有循环类型均可以使用for关键字来完成。</p>
<p>for循环的基本格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">初始语句</span><span class="p">;</span><span class="nx">条件表达式</span><span class="p">;</span><span class="nx">结束语句</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">循环体语句</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">forDemo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">forDemo2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>for循环的初始语句和结束语句都可以省略，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">forDemo3</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">i</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>go 语言中没有 while，这种写法就类似于其他编程语言中的while，在while后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p>
<blockquote>
<p><strong>无限循环</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">循环体语句</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>for循环可以通过break、goto、return、panic语句强制退出循环。</p>
<h2 id="for-range键值循环">for range（键值循环）</h2>
<p>Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 通过for range遍历的返回值有以下规律：</p>
<ol>
<li>数组、切片、字符串返回索引和值。</li>
<li>map返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ol>
<p>Go1.22版本开始支持 for range 整数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="mi">5</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="k">range</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出结果如下：</p>
<pre tabindex="0"><code>0
1
2
3
4
Hello
Hello
</code></pre><h2 id="switch-case">switch case</h2>
<p>使用switch语句可方便地对大量的值进行条件判断。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">switchDemo1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">finger</span> <span class="o">:=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">finger</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;大拇指&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;食指&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;中指&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;无名指&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="mi">5</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;小拇指&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;无效的输入！&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Go语言规定每个switch只能有一个default分支。</p>
<p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">testSwitch3</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">7</span><span class="p">;</span> <span class="nx">n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;奇数&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;偶数&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">switchDemo4</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">age</span> <span class="o">:=</span> <span class="mi">30</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">age</span> <span class="p">&lt;</span> <span class="mi">25</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;好好学习吧&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">age</span> <span class="p">&gt;</span> <span class="mi">25</span> <span class="o">&amp;&amp;</span> <span class="nx">age</span> <span class="p">&lt;</span> <span class="mi">35</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;好好工作吧&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">age</span> <span class="p">&gt;</span> <span class="mi">60</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;好好享受吧&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;活着真好&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">switchDemo5</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;a&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&#34;a&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">fallthrough</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&#34;b&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;b&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">s</span> <span class="o">==</span> <span class="s">&#34;c&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;c&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">a</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span>
</span></span></code></pre></div><p>由于 fallthrough 前面的 <code>case s == &quot;a&quot;</code> 满足条件，所以 fallthrough  后面的 case 即使不满足条件，依然会打印输出 b。</p>
<h2 id="goto跳转到指定标签">goto（跳转到指定标签）</h2>
<p>goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用goto语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gotoDemo1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">breakFlag</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 设置退出标签
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">breakFlag</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v-%v\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 外层for循环判断
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">breakFlag</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>使用 goto 来简化上面的代码，简化后如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gotoDemo2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 设置退出标签
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">goto</span> <span class="nx">breakTag</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v-%v\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 标签
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">breakTag</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;结束for循环&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="break跳出循环">break（跳出循环）</h2>
<p>break语句可以结束for、switch和select的代码块。</p>
<p>break语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。 举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">breakDemo1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">BREAKDEMO1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">j</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span> <span class="nx">BREAKDEMO1</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v-%v\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="continue继续下次循环">continue（继续下次循环）</h2>
<p>continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。</p>
<p>在 continue语句后添加标签时，表示开始标签对应的循环。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">continueDemo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">forloop1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// forloop2:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span> <span class="nx">forloop1</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v-%v\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="defer">Defer</h2>
<p>Defer 是 Go 语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Defer执行&#34;</span><span class="p">)</span> <span class="c1">// 先注册，等函数结束前再执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;程序开始&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">// 等待2秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;程序结束&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面代码结果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">程序开始</span>
</span></span><span class="line"><span class="cl"><span class="nx">程序结束</span>
</span></span><span class="line"><span class="cl"><span class="nx">Defer执行</span>
</span></span></code></pre></div><p>如果有多个 defer 语句，它们会以 LIFO（后进先出）的顺序执行。先进栈，如下：</p>
<p><img 
  src="./2025-0331-01/image-20250407204147831.png" 
  alt="image-20250407204147831" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250407204147831.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>然后再出栈：</p>
<p><img 
  src="./2025-0331-01/image-20250407204226628.png" 
  alt="image-20250407204226628" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250407204226628.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">func1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">func2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">func3</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;C&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">func1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">func2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">func3</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面代码运行，结果如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">C</span>
</span></span><span class="line"><span class="cl"><span class="nx">B</span>
</span></span><span class="line"><span class="cl"><span class="nx">A</span>
</span></span></code></pre></div><blockquote>
<p><strong>defer 和 return 的先后顺序</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">deferFunc</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;defer func called...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">returnFunc</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;return func called...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">returnAndDefer</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">deferFunc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">returnFunc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">returnAndDefer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面代码运行后，结果如下：</p>
<pre tabindex="0"><code>return func called...
defer func called...
</code></pre><p>我们从可以看到，return 是早于 defer 函数执行的，其实很好理解，defer 是被压栈的，并且是在整个函数结束后才执行，也就是执行完 { } 后内容，才会进行 defer 的出栈执行。</p>
<h1 id="数组array-">数组（Array ）</h1>
<p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组<code>大小不可变化</code>。</p>
<h2 id="数组定义">数组定义</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> 	<span class="nx">数组变量名</span>	 <span class="p">[</span><span class="nx">元素数量</span><span class="p">]</span><span class="nx">T</span>
</span></span></code></pre></div><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">b</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nx">a</span> <span class="p">=</span> <span class="nx">b</span>		 <span class="c1">//不可以这样做，因为此时a和b是不同的类型
</span></span></span></code></pre></div><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p>
<h2 id="数组初始化">数组初始化</h2>
<blockquote>
<p><strong>方法一</strong></p>
</blockquote>
<p>初始化数组时可以使用初始化列表来设置数组元素的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">testArray</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>                        <span class="c1">//数组会初始化为int类型的零值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">numArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>                 <span class="c1">//使用指定的初始值完成初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">cityArray</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;北京&#34;</span><span class="p">,</span> <span class="s">&#34;上海&#34;</span><span class="p">,</span> <span class="s">&#34;深圳&#34;</span><span class="p">}</span> <span class="c1">//使用指定的初始值完成初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">testArray</span><span class="p">)</span>                      <span class="c1">//[0 0 0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">numArray</span><span class="p">)</span>                       <span class="c1">//[1 2 0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cityArray</span><span class="p">)</span>                      <span class="c1">//[北京 上海 深圳]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>方法二</strong></p>
</blockquote>
<p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">testArray</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">numArray</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">cityArray</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;北京&#34;</span><span class="p">,</span> <span class="s">&#34;上海&#34;</span><span class="p">,</span> <span class="s">&#34;深圳&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">testArray</span><span class="p">)</span>                          <span class="c1">//[0 0 0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">numArray</span><span class="p">)</span>                           <span class="c1">//[1 2]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type of numArray:%T\n&#34;</span><span class="p">,</span> <span class="nx">numArray</span><span class="p">)</span>   <span class="c1">//type of numArray:[2]int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cityArray</span><span class="p">)</span>                          <span class="c1">//[北京 上海 深圳]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type of cityArray:%T\n&#34;</span><span class="p">,</span> <span class="nx">cityArray</span><span class="p">)</span> <span class="c1">//type of cityArray:[3]string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>方法三</strong></p>
</blockquote>
<p>我们还可以使用指定索引值的方式来初始化数组，例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>                  <span class="c1">// [0 1 0 5]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type of a:%T\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="c1">//type of a:[4]int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h2 id="数组遍历">数组遍历</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;北京&#34;</span><span class="p">,</span> <span class="s">&#34;上海&#34;</span><span class="p">,</span> <span class="s">&#34;深圳&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 方法1：for循环遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 方法2：for range遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="for-和-for-range-的注意">for 和 for range 的注意</h2>
<p><strong>数组</strong>和<strong>切片</strong>在使用的时候都存在如下注意事项：</p>
<blockquote>
<p><strong>传统 for 循环访问</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>[11 21 31]
</code></pre><blockquote>
<p><strong>for i,v := range a 的方式</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="p">=</span> <span class="nx">v</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;a[i]:&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="s">&#34;v:&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>a[i]: 10 v: 11
a[i]: 20 v: 21
a[i]: 30 v: 31
[10 20 30]
</code></pre><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="p">=</span> <span class="nx">v</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;a[i]:&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;v:&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>a[i]: 11 v: 11
a[i]: 21 v: 21
a[i]: 31 v: 31
[11 21 31]
</code></pre><blockquote>
<p><strong>for i := range a 方式</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> 
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>[11 21 31]
</code></pre><h2 id="多维数组">多维数组</h2>
<p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p>
<blockquote>
<p>二维数组定义</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span><span class="s">&#34;北京&#34;</span><span class="p">,</span> <span class="s">&#34;上海&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span><span class="s">&#34;广州&#34;</span><span class="p">,</span> <span class="s">&#34;深圳&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span><span class="s">&#34;成都&#34;</span><span class="p">,</span> <span class="s">&#34;重庆&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">//[[北京 上海] [广州 深圳] [成都 重庆]]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="c1">//支持索引取值:重庆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>二维数组的遍历</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span><span class="s">&#34;北京&#34;</span><span class="p">,</span> <span class="s">&#34;上海&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span><span class="s">&#34;广州&#34;</span><span class="p">,</span> <span class="s">&#34;深圳&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span><span class="s">&#34;成都&#34;</span><span class="p">,</span> <span class="s">&#34;重庆&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v1</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v2</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">v1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\t&#34;</span><span class="p">,</span> <span class="nx">v2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">北京</span>	<span class="nx">上海</span>	
</span></span><span class="line"><span class="cl"><span class="nx">广州</span>	<span class="nx">深圳</span>	
</span></span><span class="line"><span class="cl"><span class="nx">成都</span>	<span class="nx">重庆</span>	
</span></span></code></pre></div><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//支持的写法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;北京&#34;</span><span class="p">,</span> <span class="s">&#34;上海&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;广州&#34;</span><span class="p">,</span> <span class="s">&#34;深圳&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;成都&#34;</span><span class="p">,</span> <span class="s">&#34;重庆&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//❌不支持多维数组的内层使用...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">b</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;北京&#34;</span><span class="p">,</span> <span class="s">&#34;上海&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;广州&#34;</span><span class="p">,</span> <span class="s">&#34;深圳&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="s">&#34;成都&#34;</span><span class="p">,</span> <span class="s">&#34;重庆&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="切片slice">切片（Slice）</h1>
<p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">arraySum</span><span class="p">(</span><span class="nx">x</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">x</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sum</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">sum</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。</p>
<p>再比如：</p>
<pre tabindex="0"><code>a := [3]int{1, 2, 3}
</code></pre><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p>
<p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p>
<h2 id="切片的内部实现">切片的内部实现</h2>
<p>切片是一个很小的对象，它对底层的数组（内部是通过数组保存数据的）进行了抽象，并提供相关的操作方法。</p>
<p>切片是一个有三个字段的数据结构，这些数据结构包含 Golang 需要操作底层数组的元数据。这 3 个字段分别是指向底层数组的指针、切片访问的元素的个数（即length）和切片允许增长到的元素个数（即capacity）。</p>
<p>可以理解成 capacity 表示内部数组的总长度，length 表示当前已经使用的数组的长度。length 永远不能超过 capacity。</p>
<p><img 
  src="./2025-0331-01/image-20250410205905011.png" 
  alt="image-20250410205905011" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250410205905011.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>如上图，切片支持 append 操作可以将新的内容追加到底层数组，也就是填充上面的灰色格子。如果格子满了，切片就需要扩容，底层的数组就会更换。</p>
<p>形象一点说，切片变量是底层数组的视图，底层数组是卧室，切片变量是卧室的窗户。通过窗户我们可以看见底层数组的一部分或全部。一个卧室可以有多个窗户，不同的窗户能看到卧室的不同部分。</p>
<h2 id="切片定义">切片定义</h2>
<p>声明切片类型的基本语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">name</span> <span class="p">[]</span><span class="nx">T</span>
</span></span></code></pre></div><p>其中，<code>name</code>表示变量名，<code>T</code>表示切片中的元素类型</p>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 声明切片类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">a</span> <span class="p">[]</span><span class="kt">string</span>              <span class="c1">//声明一个字符串切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>             <span class="c1">//声明一个整型切片并初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">bool</span><span class="p">{</span><span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">}</span> <span class="c1">//声明一个布尔切片并初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">d</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">bool</span><span class="p">{</span><span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">}</span> <span class="c1">//声明一个布尔切片并初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h2 id="切片的创建和初始化">切片的创建和初始化</h2>
<p>在 Golang 中可以通过多种方式创建和初始化切片。</p>
<p><img 
  src="./2025-0331-01/image-20250410204307895.png" 
  alt="image-20250410204307895" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250410204307895.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>我们主要来了解<code>字面量</code>和<code>make</code> 及 <code>从切片以及数组截取</code></p>
<blockquote>
<p><strong>字面量</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span><span class="mi">100</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span>
</span></span></code></pre></div><pre tabindex="0"><code>[0 1 2 3 0 0 0 0 100]
</code></pre><p>注意的是上面的代码例子中使用了索引号，直接赋值，这样，其他未注明的元素则默认 <code>0 值</code>。</p>
<blockquote>
<p><strong>make</strong></p>
</blockquote>
<p>使用 Golang 内置的 make() 函数创建切片，此时需要传入一个参数来指定切片的长度：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 创建一个整型切片
</span></span></span><span class="line"><span class="cl"><span class="c1">// 其长度和容量都是 5 个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span></code></pre></div><p>此时只指定了切片的长度，那么切片的容量和长度相等。也可以分别指定长度和容量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 创建一个整型切片
</span></span></span><span class="line"><span class="cl"><span class="c1">// 其长度为 3 个元素，容量为 5 个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></span></code></pre></div><p>分别指定长度和容量时，创建的切片，底层数组的长度是指定的容量，但是初始化后并不能访问所有的数组元素。</p>
<blockquote>
<p><strong>从切片或数组 “截取”</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>  		<span class="c1">// s := a[low:high]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;s:%v len(s):%v cap(s):%v\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s2</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>  		<span class="c1">// 索引的上限是cap(s)而不是len(s)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;s2:%v len(s2):%v cap(s2):%v\n&#34;</span><span class="p">,</span> <span class="nx">s2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s2</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>s:[2 3] len(s):2 cap(s):4
s2:[5] len(s2):1 cap(s2):1
</code></pre><p>注意：</p>
<p><img 
  src="./2025-0331-01/image-20250411204403716.png" 
  alt="image-20250411204403716" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250411204403716.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h2 id="限制切片的容量">限制切片的容量</h2>
<p>上面我们了解了切片表达式 a[low:high]，那么实际完整的切片表达式应该是 a[low:high:max]</p>
<p>low 和 high 我们很熟悉，但这个 max 是啥意思呢 ？</p>
<p>max 主要就是限制切片的容量，防止某些数据的修改，可以更安全的共享底层数组。我们直接看下图   ：</p>
<p><img 
  src="./2025-0331-01/image-20250411224836507.png" 
  alt="image-20250411224836507" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250411224836507.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h2 id="nil-和空切片">nil 和空切片</h2>
<blockquote>
<p><strong>什么是空切片 ？</strong></p>
</blockquote>
<p>在Go中对空切片的定义是这样的：<strong>如果切片的长度是0，那么称该切片是空切片</strong>。</p>
<p>我们通过一个例子来看下定义切片的不同方式。同时我们判断切片是否是nil以及它的长度和容量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//定义变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;1:nil=%t, len=%d, cap=%d\n&#34;</span><span class="p">,</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//组合字面量方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;2:nil=%t, len=%d, cap=%d\n&#34;</span><span class="p">,</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//make方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;3: nil=%t, len=%d, cap=%d\n&#34;</span><span class="p">,</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>1: nil=true, len=0, cap=0
2: nil=false, len=0, cap=0
3: nil=false, len=0, cap=0
</code></pre><p>根据空切片的定义以及输出结果，我们发现3个切片的长度和容量都为0，即都是空切片。</p>
<p>同时我们也发现只有第一个切片为nil。那nil切片又是什么呢？</p>
<blockquote>
<p><strong>什么是 nil 切片 ？</strong></p>
</blockquote>
<p>在 go 中 nil 代表的是 pointer、channel、func、interface、map或slice类型的零值。</p>
<p>那么，nil 切片和非 nil 切片的区别是啥呢 ？</p>
<p>前面我们了解了，slice的底层结构体中是由3个字段构成的：长度、容量和指向底层数组的指针字段。</p>
<p>而nil切片除了长度和容量都是0之外，还有就是<strong>ptr指针不指向任何底层数组，这也是和空切片的本质区别</strong>。</p>
<p>如下图表示一个nil切片：</p>
<p><img 
  src="./2025-0331-01/image-20250413174301140.png" 
  alt="image-20250413174301140" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250413174301140.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>简单来说：</p>
<ul>
<li>nil切片的长度和容量都是0，空切片的长度为0，容量由指向的底层数组决定</li>
<li>空切片 != nil切片</li>
<li>nil切片的ptr指针是nil，而空切片的ptr指针指向底层数组的地址</li>
</ul>
<h2 id="切片的赋值拷贝">切片的赋值拷贝</h2>
<p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">//[0 0 0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">s2</span> <span class="o">:=</span> <span class="nx">s1</span>             <span class="c1">//将s1直接赋值给s2，s1和s2共用一个底层数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span> <span class="c1">//[100 0 0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span> <span class="c1">//[100 0 0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h2 id="切片的遍历">切片的遍历</h2>
<p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="append-添加切片元素">append 添加切片元素</h2>
<p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>        <span class="c1">// [1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1">// [1 2 3 4]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">s2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span>  
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">s2</span><span class="o">...</span><span class="p">)</span>    <span class="c1">// [1 2 3 4 5 6 7]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><strong>注意</strong>：通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span></code></pre></div><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>  <span class="c1">// 没有必要初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>  <span class="c1">// 没有必要初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span></code></pre></div><p>由于每个切片指向一个底层数组，当使用 append 添加元素的时候，如果底层数组容量够用就添加元素。当底层数组不能够容纳新增的元素时，切片就会按照一定的策略进行 “扩容”，此时该切片指向的底层数组就会更换。</p>
<p>扩容操作往往发生在 append 函数调用的时候，所以我们通常都需要用原变量接收append函数的返回值。</p>
<p>我们来看一个简单的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span> <span class="c1">// 空切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;初始: len=%d cap=%d ptr=%p\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;追加1个元素: len=%d cap=%d ptr=%p\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;追加2个元素: len=%d cap=%d ptr=%p\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">     
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;追加3个元素: len=%d cap=%d ptr=%p\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;追加4个元素: len=%d cap=%d ptr=%p\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="append-底层扩容机制">append 底层扩容机制</h2>
<blockquote>
<p><strong>最简单的扩容机制—追加一个元素且在 1024 字节以内</strong></p>
</blockquote>
<ul>
<li>如果新的大小在 cap 大小以内自然不需要考虑扩容问题</li>
<li>如果超出 cap 则 cap 翻倍</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">byte</span> <span class="c1">// 初始切片为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After append %2d: len=%2d, cap=%2d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>After append  0: len= 1, cap= 1
After append  1: len= 2, cap= 2
After append  2: len= 3, cap= 4
After append  3: len= 4, cap= 4
After append  4: len= 5, cap= 8
After append  5: len= 6, cap= 8
After append  6: len= 7, cap= 8
After append  7: len= 8, cap= 8
After append  8: len= 9, cap=16
...
</code></pre><blockquote>
<p><strong>追加一个元素超过 1024 字节</strong></p>
</blockquote>
<ul>
<li>cap 超过 1024 字节，扩容则变为 1.25 倍而不再是 2 倍（当然这只是之前版本，现在 go 的切片扩容已经不会直接由 2 倍 降低 为 1.25 倍，而是更平滑的降低）</li>
</ul>
<p>这里以 1.25 倍为例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span> <span class="c1">// 初始容量 1024
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">lastCap</span> <span class="o">:=</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">lastCap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;len=%4d, old cap=%4d =&gt; new cap=%4d\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nx">lastCap</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">lastCap</span> <span class="p">=</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>...
len=1025, old cap=1024 =&gt; new cap=1280
len=1281, old cap=1280 =&gt; new cap=1600
len=1601, old cap=1600 =&gt; new cap=2000
...
</code></pre><blockquote>
<p><strong>复杂扩容——追加多个元素</strong></p>
</blockquote>
<ul>
<li>
<p>追加多个元素的时候，当追加后的长度超过了 cap 的二倍时，则扩容为原大小直接加追加大小，如下：</p>
<p><code>newCap = len(oldSlice) + len(addedElements)</code></p>
</li>
</ul>
<p>当前容量是 <code>cap = 2</code>，当前长度是 <code>len = 2</code>，次性追加 3 个元素（追加后 <code>len = 5</code>），因为 <code>5 &gt; 2 * 2</code>，<strong>不是常规翻倍（4）就够的情况</strong>，所以直接扩容到 <code>5</code></p>
<blockquote>
<p><strong>golang 的实际扩容策略</strong></p>
</blockquote>
<p>但实际上 go 的切片扩容策略真的是和上面一样吗 ？</p>
<p>当然不是，如果依据上面的第三条策略，自然就发现问题了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">e</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int32</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;cap of e before:&#34;</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="nx">e</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;cap of e after:&#34;</span><span class="p">,</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>cap of e before: 2
cap of e after: 6
</code></pre><p>很明显不符合第三条策略，上面的规则来自于 go 扩容机制 <code>runtime/slice</code>包中的 <code>growslice</code> 源代码，只是我们所总结的只是 go 扩容机制的第一步，也就是他所期望的 cap 大小，真正分配时又会有其他的影响因素，例如在分配时 span class ，也就是 go 内存分配机制的 span 大小种类。</p>
<p>例如我们上面的代码， 我们期望分到 5 个元素的长度，其中 int 类型占 8 个字节，也就是分得 40 个字节的内存。但实际上并没有 40 字节大小的 span，所以需要向上取整，得到一个 48 字节大小的 span ，也就是最终分得 cap 长度为 6。</p>
<p>到这里就结束了吗，当然不是，如果你好奇的话，继续扩大追加的元素个数，就会发现扩容机制再次发生改变，也就是说，span class 的大小也只是其中的一个影响因素。</p>
<p>实际切片的扩容非常比较复杂，我们纠结切片的扩容确实没啥必要，它与CPU位数、元素大小、是否包含指针、追加个数等都有关系。</p>
<p>在实际使用中，如果能够确定切片的容量范围，比较合适的做法是：切片初始化时就分配足够的容量空间，在append追加操作时，就不用再考虑扩容带来的性能损耗问题。</p>
<h1 id="map">Map</h1>
<p>golang 中提供映射关系容器为 Map，其内部使用散列表（hash）实现。</p>
<p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p>
<h2 id="map-定义">Map 定义</h2>
<p>Go语言中map的定义语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">map</span><span class="p">[</span><span class="nx">KeyType</span><span class="p">]</span><span class="nx">ValueType</span>
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>KeyType：表示键的类型。</li>
<li>ValueType:表示键对应的值的类型。</li>
</ul>
<p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">KeyType</span><span class="p">]</span><span class="nx">ValueType</span><span class="p">,</span> <span class="p">[</span><span class="nx">cap</span><span class="p">])</span>
</span></span></code></pre></div><p>其中cap表示map的容量，该参数虽然<code>不是必须的</code>。作为一个新手，大多数情况下都不会指定容量，golang 在需要的时候会自动进行扩容，但指定容量可以提高性能，避免频繁的扩容。</p>
<h2 id="map-的基础使用">Map 的基础使用</h2>
<p>map中的<code>数据都是成对出现的</code>，map的基本使用示例代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">90</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;小明&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">scoreMap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;小明&#34;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type of a:%T\n&#34;</span><span class="p">,</span> <span class="nx">scoreMap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>map[小明:100 张三:90]
100
type of a:map[string]int
</code></pre><p>map也支持在声明的时候填充元素，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">userInfo</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;username&#34;</span><span class="p">:</span> <span class="s">&#34;沙河小王子&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;password&#34;</span><span class="p">:</span> <span class="s">&#34;123456&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">userInfo</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>map[password:123456 username:沙河小王子]
</code></pre><h2 id="map-中插入数据">Map 中插入数据</h2>
<p>在切片中，我们用 append 添加数据，在 Map 中就是用 <code>map[key] = value</code>  的形式，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span> <span class="c1">//初始化随机数种子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">scoreMap</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;stu%02d&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">//生成stu开头的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">value</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>          <span class="c1">//生成0~99的随机整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">scoreMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">scoreMap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>map[stu00:75 stu01:1 stu02:72 stu03:86 stu04:79 stu05:95 stu06:12 stu07:50 stu08:81 stu09:76]
</code></pre><h2 id="判断某个键是否存在">判断某个键是否存在</h2>
<p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
</span></span></code></pre></div><p>举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">90</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;小明&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 判断是否存在张三
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;查无此人&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>90
</code></pre><h2 id="map-的遍历">Map 的遍历</h2>
<p>Go语言中使用<code>for range</code>遍历map，和切片数组类似。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">90</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;小明&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;娜扎&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">60</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scoreMap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>但我们只想遍历key的时候，可以按下面的写法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">90</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;小明&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;娜扎&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">60</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scoreMap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p>
<p>遍历时候当然也存在上面数组和切片中 <code>for range 的注意</code>问题，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 初始化 map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">scoreMap</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;张三&#34;</span><span class="p">:</span> <span class="mi">90</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;李四&#34;</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 拷贝修改（无效）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scoreMap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">v</span> <span class="o">+=</span> <span class="mi">5</span> <span class="c1">// 只是修改了副本 v
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;尝试用副本修改后的结果：&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scoreMap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 正确方式：通过 key 修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scoreMap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">scoreMap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;通过 key 修改后的结果：&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scoreMap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="使用delete函数删除键值对">使用delete()函数删除键值对</h2>
<p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nb">delete</span><span class="p">(</span><span class="kd">map</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span><span class="nx">S</span>
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>map:表示要删除键值对的map</li>
<li>key:表示要删除的键值对的键</li>
</ul>
<p>示例代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;张三&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">90</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;小明&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="nx">scoreMap</span><span class="p">[</span><span class="s">&#34;娜扎&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">60</span>
</span></span><span class="line"><span class="cl">	<span class="nb">delete</span><span class="p">(</span><span class="nx">scoreMap</span><span class="p">,</span> <span class="s">&#34;小明&#34;</span><span class="p">)</span><span class="c1">//将小明:100从map中删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scoreMap</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="按照指定顺序遍历map">按照指定顺序遍历map</h2>
<p>注意：在 Map 遍历的时候，顺序是随机的</p>
<p>我们可以对 key 排序后再遍历，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rand</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span> <span class="c1">//初始化随机数种子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">scoreMap</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;stu%02d&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">//生成stu开头的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">value</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>          <span class="c1">//生成0~99的随机整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">scoreMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//取出map中的所有key存入切片keys
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">keys</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scoreMap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">keys</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">keys</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//对切片进行排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sort</span><span class="p">.</span><span class="nf">Strings</span><span class="p">(</span><span class="nx">keys</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//按照排序后的key遍历map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">keys</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">scoreMap</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">stu00</span> <span class="mi">72</span>
</span></span><span class="line"><span class="cl"><span class="nx">stu01</span> <span class="mi">56</span>
</span></span><span class="line"><span class="cl"><span class="nx">stu02</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl"><span class="nx">stu03</span> <span class="mi">80</span>
</span></span><span class="line"><span class="cl"><span class="nx">stu04</span> <span class="mi">17</span>
</span></span><span class="line"><span class="cl"><span class="nx">stu05</span> <span class="mi">90</span>
</span></span><span class="line"><span class="cl"><span class="nx">stu06</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span></code></pre></div><h2 id="切片嵌套-map元素为map类型的切片">切片嵌套 Map：元素为map类型的切片</h2>
<p>一个切片，里面每个元素是一个 map。如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">mapSlice</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">mapSlice</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;index:%d value:%v\n&#34;</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;after init&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 对切片中的map元素进行初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mapSlice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mapSlice</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#34;name&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;小王子&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mapSlice</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#34;password&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;123456&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mapSlice</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#34;address&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;沙河&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">mapSlice</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;index:%d value:%v\n&#34;</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>index:0 value:map[]
index:1 value:map[]
index:2 value:map[]
after init
index:0 value:map[address:沙河 name:小王子 password:123456]
index:1 value:map[]
index:2 value:map[]
</code></pre><h2 id="map嵌套切片值为切片类型的map">Map嵌套切片：值为切片类型的map</h2>
<p>一个 map，每个 key 对应一个切片。如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">sliceMap</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">sliceMap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;after init&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">key</span> <span class="o">:=</span> <span class="s">&#34;中国&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">sliceMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">value</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">value</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="s">&#34;北京&#34;</span><span class="p">,</span> <span class="s">&#34;上海&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sliceMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">sliceMap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>map[]
after init
map[中国:[北京 上海]]
</code></pre><h1 id="函数">函数</h1>
<h2 id="函数-1">函数</h2>
<h3 id="函数定义">函数定义</h3>
<p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">函数名</span><span class="p">(</span><span class="nx">参数</span><span class="p">)(</span><span class="nx">返回值</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nx">函数体</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</li>
<li>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用<code>,</code>分隔。</li>
<li>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用<code>()</code>包裹，并用<code>,</code>分隔。</li>
<li>函数体：实现指定功能的代码块。</li>
</ul>
<p>我们先来定义一个求两个数之和的函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">intSum</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">sayHello</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello 沙河&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="函数调用">函数调用</h3>
<p>定义了函数之后，我们可以通过<code>函数名()</code>的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">sayHello</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ret</span> <span class="o">:=</span> <span class="nf">intSum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意，调用有返回值的函数时，可以不接收其返回值。</p>
<h3 id="参数">参数</h3>
<blockquote>
<p><strong>类型简写</strong></p>
</blockquote>
<p>函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">intSum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面的代码中，<code>intSum</code>函数有两个参数，这两个参数的类型均为<code>int</code>，因此可以省略<code>x</code>的类型，因为<code>y</code>后面有类型说明，<code>x</code>参数也是该类型。</p>
<blockquote>
<p><strong>可变参数</strong></p>
</blockquote>
<p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p>
<p>注意：可变参数通常要作为函数的最后一个参数。</p>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义一个可变参数函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">intSum2</span><span class="p">(</span><span class="nx">x</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;接收到的参数切片：&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="c1">// x 是一个 int 类型的切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">x</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">sum</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用可变参数函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ret1</span> <span class="o">:=</span> <span class="nf">intSum2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ret2</span> <span class="o">:=</span> <span class="nf">intSum2</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ret3</span> <span class="o">:=</span> <span class="nf">intSum2</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ret4</span> <span class="o">:=</span> <span class="nf">intSum2</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 打印结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;返回值：&#34;</span><span class="p">,</span> <span class="nx">ret1</span><span class="p">,</span> <span class="nx">ret2</span><span class="p">,</span> <span class="nx">ret3</span><span class="p">,</span> <span class="nx">ret4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">接收到的参数切片</span><span class="err">：</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="nx">接收到的参数切片</span><span class="err">：</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">接收到的参数切片</span><span class="err">：</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">接收到的参数切片</span><span class="err">：</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">返回值</span><span class="err">：</span> <span class="mi">0</span> <span class="mi">10</span> <span class="mi">30</span> <span class="mi">60</span>
</span></span></code></pre></div><p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 固定参数 + 可变参数函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">intSum3</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;固定参数：&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&#34;可变参数切片：&#34;</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sum</span> <span class="o">:=</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">y</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">sum</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ret5</span> <span class="o">:=</span> <span class="nf">intSum3</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ret6</span> <span class="o">:=</span> <span class="nf">intSum3</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ret7</span> <span class="o">:=</span> <span class="nf">intSum3</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ret8</span> <span class="o">:=</span> <span class="nf">intSum3</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;返回值：&#34;</span><span class="p">,</span> <span class="nx">ret5</span><span class="p">,</span> <span class="nx">ret6</span><span class="p">,</span> <span class="nx">ret7</span><span class="p">,</span> <span class="nx">ret8</span><span class="p">)</span> <span class="c1">// 100 110 130 160
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>固定参数： 100 可变参数切片： []
固定参数： 100 可变参数切片： [10]
固定参数： 100 可变参数切片： [10 20]
固定参数： 100 可变参数切片： [10 20 30]
返回值： 100 110 130 160
</code></pre><p>本质上，函数的可变参数是通过切片来实现的。</p>
<h3 id="返回值">返回值</h3>
<p>Go语言中通过<code>return</code>关键字向外输出返回值。</p>
<blockquote>
<p><strong>多返回值</strong></p>
</blockquote>
<p>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">calc</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sum</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sub</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">sum</span><span class="p">,</span> <span class="nx">sub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>返回值命名</strong></p>
</blockquote>
<p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">calc</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="nx">sub</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 等同于 func calc(x, y int) (sum int, sub int) {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sum</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sub</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span> <span class="o">:=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">a</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nf">calc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;x =&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&#34;y =&#34;</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>x = 8 y = 2
</code></pre><p>这里 return 默认自动返回定义的返回值 sum 和 sub</p>
<p>如果写成如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">calc</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="nx">sub</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 等同于 func calc(x, y int) (sum int, sub int) {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sum</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sub</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span> <span class="o">:=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">a</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nf">calc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;x =&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="s">&#34;y =&#34;</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>x = 1 y = 2
</code></pre><p>此时 return 返回的是 a 和 b 的值。</p>
<blockquote>
<p><strong>返回值补充</strong></p>
</blockquote>
<p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">someFunc</span><span class="p">(</span><span class="nx">x</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span> <span class="c1">// 没必要返回空切片[]int{}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="函数的进阶">函数的进阶</h2>
<h3 id="变量的作用域">变量的作用域</h3>
<p>无非就是全局变量和局部变量，这里直接省略，前面在变量和常量中已经提过。</p>
<h3 id="自定义函数类型">自定义函数类型</h3>
<p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p>
<pre tabindex="0"><code>type calculation func(int, int) int
</code></pre><p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p>
<p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">sub</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>add和sub都能赋值给calculation类型的变量。如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义函数类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">calculation</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 实现两个函数，符合 calculation 类型签名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">sub</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">c</span> <span class="nx">calculation</span> <span class="c1">// 声明一个 calculation 类型的变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="p">=</span> <span class="nx">add</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;10 + 5 =&#34;</span><span class="p">,</span> <span class="nf">c</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">// 输出：10 + 5 = 15
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="p">=</span> <span class="nx">sub</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;10 - 5 =&#34;</span><span class="p">,</span> <span class="nf">c</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">// 输出：10 - 5 = 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>10 + 5 = 15
10 - 5 = 5
</code></pre><h3 id="高阶函数">高阶函数</h3>
<p>高阶函数分为函数作为参数和函数作为返回值两部分。</p>
<blockquote>
<p><strong>函数作为参数</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">calc</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">op</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">op</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ret2</span> <span class="o">:=</span> <span class="nf">calc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="nx">add</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ret2</span><span class="p">)</span> <span class="c1">//30
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>函数作为返回值</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">do</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="s">&#34;+&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">add</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="s">&#34;-&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">sub</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;无法识别的操作符&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>注意：如果返回值只有一个函数，那么写法经常是不带括号的，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">adder2</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>	
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>   
</span></span><span class="line"><span class="cl"><span class="c1">// 当然也可以带括号，如下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">adder2</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div><h3 id="匿名函数和闭包">匿名函数和闭包</h3>
<blockquote>
<p><strong>匿名函数</strong></p>
</blockquote>
<p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p>
<pre tabindex="0"><code>func(参数)(返回值){
    函数体
}
</code></pre><p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 将匿名函数保存到变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">add</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="c1">// 通过变量调用匿名函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">//自执行函数：匿名函数定义完加()直接执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>30
70
</code></pre><p>匿名函数多用于实现回调函数和闭包。</p>
<blockquote>
<p><strong>闭包</strong></p>
</blockquote>
<p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，<code>闭包=函数+引用环境</code>。</p>
<p>首先我们来看一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">adder</span><span class="p">()</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">x</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">x</span> <span class="o">+=</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">f</span> <span class="p">=</span> <span class="nf">adder</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="c1">//10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span> <span class="c1">//30
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span> <span class="c1">//60
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">f1</span> <span class="o">:=</span> <span class="nf">adder</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f1</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span> <span class="c1">//40
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f1</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span> <span class="c1">//90
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>我们来分析一下上面的代码：</p>
<ul>
<li><code>var f = adder()</code> 把 adder() 函数的返回值赋值给了变量 f，adder() 的返回值是个函数，并且这个函数本身并没有定义变量x，而是引用了它所在的环境（函数adder）中定义的变量x</li>
</ul>
<p><img 
  src="./2025-0331-01/image-20250504091410948.png" 
  alt="image-20250504091410948" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250504091410948.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<ul>
<li>所以 f(10)，实际如下</li>
</ul>
<p><img 
  src="./2025-0331-01/image-20250504091801623.png" 
  alt="image-20250504091801623" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250504091801623.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<ul>
<li>由于 f(10) 返回了变量 x=10，那么 f(20) 在调用的时候如下：</li>
</ul>
<p><img 
  src="./2025-0331-01/image-20250504095405474.png" 
  alt="image-20250504095405474" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250504095405474.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<ul>
<li>后续的过程也都是一样的， 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。</li>
</ul>
<p>通过上面的分析，实际上我们可以将闭包简单理解成带有记忆功能的函数。然后我们来看一下闭包的一些进阶</p>
<blockquote>
<p><strong>闭包进阶示例1</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">adder2</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">x</span> <span class="o">+=</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">f</span> <span class="p">=</span> <span class="nf">adder2</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="c1">//20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span> <span class="c1">//40
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span> <span class="c1">//70
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">f1</span> <span class="o">:=</span> <span class="nf">adder2</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f1</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span> <span class="c1">//60
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f1</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span> <span class="c1">//110
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>闭包的进阶示例2</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makeSuffixFunc</span><span class="p">(</span><span class="nx">suffix</span> <span class="kt">string</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">HasSuffix</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">suffix</span><span class="p">)</span> <span class="p">{</span>		<span class="c1">//判断字符串 name 是否以 suffix 结尾。如果是，返回 true；否则返回 false。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="nx">name</span> <span class="o">+</span> <span class="nx">suffix</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">name</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">jpgFunc</span> <span class="o">:=</span> <span class="nf">makeSuffixFunc</span><span class="p">(</span><span class="s">&#34;.jpg&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">txtFunc</span> <span class="o">:=</span> <span class="nf">makeSuffixFunc</span><span class="p">(</span><span class="s">&#34;.txt&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">jpgFunc</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">))</span> <span class="c1">//test.jpg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">txtFunc</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">))</span> <span class="c1">//test.txt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>闭包的进阶示例3</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">calc</span><span class="p">(</span><span class="nx">base</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">add</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">base</span> <span class="o">+=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">base</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">sub</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">base</span> <span class="o">-=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">base</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">add</span><span class="p">,</span> <span class="nx">sub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">f1</span><span class="p">,</span> <span class="nx">f2</span> <span class="o">:=</span> <span class="nf">calc</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f1</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nf">f2</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="c1">//11 9
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f1</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="nf">f2</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="c1">//12 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">f1</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="nf">f2</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span> <span class="c1">//13 7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h2 id="defer-语句">defer 语句</h2>
<p>Defer 是 Go 语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后执行。举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Defer执行&#34;</span><span class="p">)</span> <span class="c1">// 先注册，等函数结束前再执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;程序开始&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">// 等待2秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;程序结束&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>程序开始
程序结束
Defer执行
</code></pre><blockquote>
<p><strong>defer 执行顺序</strong></p>
</blockquote>
<p>如果有多个 defer 语句，它们会以 LIFO（后进先出）的顺序执行。先进栈，如下：</p>
<img src="./2025-0331-01/image-20250304192813775.png" alt="image-20250304192813775" style="zoom: 33%;" />
<p>然后再出栈：</p>
<img src="./2025-0331-01/image-202503041929543812.png" alt="image-202503041929543812" style="zoom:33%;" />
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">func1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">func2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">func3</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;C&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">func1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">func2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">func3</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>C
B
A
</code></pre><blockquote>
<p><strong>defer 和 return 的顺序</strong></p>
</blockquote>
<p>在Go语言的函数中<code>return</code>语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而<code>defer</code>语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：</p>
<p><img 
  src="./2025-0331-01/image-20250504102856762.png" 
  alt="image-20250504102856762" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250504102856762.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>从上图中，我们可以了解到 return 是早于 defer 执行的，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">deferFunc</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;defer func called...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">returnFunc</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;return func called...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">returnAndDefer</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">deferFunc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">returnFunc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">returnAndDefer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>return func called...
defer func called...
</code></pre><blockquote>
<p><strong>defer 经典案例1</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">f1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="o">:=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">x</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">f2</span><span class="p">()</span> <span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">x</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">f3</span><span class="p">()</span> <span class="p">(</span><span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="o">:=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">x</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">f4</span><span class="p">()</span> <span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">x</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;f1:&#34;</span><span class="p">,</span> <span class="nf">f1</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;f2:&#34;</span><span class="p">,</span> <span class="nf">f2</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;f3:&#34;</span><span class="p">,</span> <span class="nf">f3</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;f4:&#34;</span><span class="p">,</span> <span class="nf">f4</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>f1: 5
f2: 6
f3: 5
f4: 5
</code></pre><p>直接 AI 分析一下上面的代码：</p>
<img src="./2025-0331-01/image-20250504105822616.png" alt="image-20250504105822616" style="zoom: 67%;" />
<img src="./2025-0331-01/image-20250504105906587.png" alt="image-20250504105906587" style="zoom:67%;" />
<img src="./2025-0331-01/image-20250504105921657.png" alt="image-20250504105921657" style="zoom:67%;" />
<img src="./2025-0331-01/image-20250504110214223.png" alt="image-20250504110214223" style="zoom:67%;" />
<blockquote>
<p><strong>defer 经典案例2</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">calc</span><span class="p">(</span><span class="nx">index</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">ret</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="o">:=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="nx">y</span> <span class="o">:=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">calc</span><span class="p">(</span><span class="s">&#34;AA&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nf">calc</span><span class="p">(</span><span class="s">&#34;A&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="p">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nf">calc</span><span class="p">(</span><span class="s">&#34;BB&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nf">calc</span><span class="p">(</span><span class="s">&#34;B&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">y</span> <span class="p">=</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>A 1 2 3
B 10 2 12
BB 10 12 22
AA 1 3 4
</code></pre><h2 id="panic-和-recover">Panic 和 Recover</h2>
<p>golang 中有两个经常成对出现的关键字 panic 和 recover，这两个关键字与上面的 defer 有紧密的关系。</p>
<p>panic 与 recover 是 Go 的两个内置函数，这两个内置函数用于处理 Go 运行时的错误，panic 用于主动抛出错误，recover 用来捕获 panic 抛出的错误。</p>
<p>panic 用于中断程序的正常执行，通常在发生严重错误的时候触发。引发 <code>panic</code> 有两种情况，一是程序主动调用，二是程序产生运行时错误，由运行时检测并退出。比如：数组越界、访问 <code>nil</code> 指针、运行时的致命错误、你主动调用 <code>panic()</code> 等等。</p>
<p>比如：数组越界造成 panic，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;访问数组第 3 个元素:&#34;</span><span class="p">,</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">// 正常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;访问数组第 4 个元素:&#34;</span><span class="p">,</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="c1">// 超出范围，触发 panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250504115653370.png" 
  alt="image-20250504115653370" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250504115653370.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>那么，我们如何主动调用 panic 呢，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;程序开始&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;发生严重错误&#34;</span><span class="p">)</span> <span class="c1">// 触发 panic，程序会崩溃
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;这行不会执行&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250504120311041.png" 
  alt="image-20250504120311041" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250504120311041.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>运行程序时，panic 一旦被引发调用就会导致程序崩溃，go 语言中，recover 内置函数，专门用于捕获并恢复程序在 panic 状态下的控制流，防止程序崩溃。</p>
<p>通过 recover，程序可以从 panic 状态中恢复，并继续执行后续的代码，recover 主要有以下的作用：</p>
<ul>
<li>防止程序崩溃：捕获 panic 后，程序可以继续执行，而不是中断</li>
<li>返回错误信息：recover 可以获取到 panic 中的错误信息，有助于在程序中作日志记录或其他的错误处理</li>
<li>恢复控制权：当发生 panic 时，recover 会恢复控制流，使程序能够恢复正常状态</li>
</ul>
<p>panic 函数的执行原理：</p>
<ul>
<li>发生 <code>panic</code> 后，程序会从调用 <code>panic</code> 的函数位置或发生 <code>panic</code> 的地方立即返回，逐层向上执行函数的 <code>defer</code> 语句，然后逐层打印函数调用堆栈，直到被 <code>recover</code> 捕获或运行到最外层函数。</li>
</ul>
<p>如果没有 recover 会直接崩溃，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 模拟一个发生 panic 的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">functionA</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;进入函数 A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 触发 panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;A 中发生了不可恢复的错误！&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 函数 B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">functionB</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;函数 B 中的 defer 被执行&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;进入函数 B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用 functionA
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">functionA</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 函数 C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">functionC</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;函数 C 中的 defer 被执行&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;进入函数 C&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用 functionB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">functionB</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;主函数中的 defer 被执行&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;进入主函数&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用 functionC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">functionC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 这行代码不会执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;这行代码不会执行&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250507204236850.png" 
  alt="image-20250507204236850" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507204236850.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>分析上面的代码压栈顺序：</p>
<pre tabindex="0"><code>main → functionC → functionB → functionA
</code></pre><p><code>defer</code> 执行顺序（出栈顺序）：</p>
<ul>
<li><code>functionA</code> 执行完毕并触发 <code>panic</code>，栈开始出栈。
<ul>
<li><code>functionB</code> 的 <code>defer</code> 被执行。</li>
<li>然后是 <code>functionC</code> 的 <code>defer</code>。</li>
<li>最后是 <code>main</code> 的 <code>defer</code>。</li>
<li>由于没有 <code>recover</code>，程序崩溃并打印堆栈跟踪信息。</li>
</ul>
</li>
</ul>
<p>recover 函数执行原理：</p>
<ul>
<li><code>recover</code> 用来捕获 <code>panic</code>，阻止 <code>panic</code> 继续向上传递。<code>recover()</code> 和 <code>defer</code> 一起使用，但是 <code>defer</code> 只有在后面的函数体内直接被掉用才能捕获 <code>panic</code> 来终止异常，否则返回 <code>nil</code>，异常继续向外传递。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 模拟一个发生 panic 的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">functionA</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;进入函数 A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 触发 panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;A 中发生了不可恢复的错误！&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 函数 B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">functionB</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用 defer 捕获 panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 捕获到 panic，程序不会崩溃，恢复继续执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;函数 B 中捕获到 panic:&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;函数 B 中的 defer 被执行&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;进入函数 B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用 functionA
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">functionA</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 函数 C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">functionC</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用 defer 捕获 panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 捕获到 panic，程序不会崩溃，恢复继续执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;函数 C 中捕获到 panic:&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;函数 C 中的 defer 被执行&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;进入函数 C&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用 functionB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">functionB</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用 defer 捕获 panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 捕获到 panic，程序不会崩溃，恢复继续执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;主函数中捕获到 panic:&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;主函数中的 defer 被执行&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;进入主函数&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用 functionC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">functionC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 这行代码会执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;这行代码会执行&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250507204746321.png" 
  alt="image-20250507204746321" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507204746321.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>我们在看一个典型案例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Demo</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//定义10个元素的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">arr</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//错误拦截要在产生错误前设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//设置recover拦截错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//产生panic异常  打印错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//根据函数参数为数组元素赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//如果i的值超过数组下标 会报错误：数组下标越界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Demo</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//产生错误后 程序继续
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;程序继续执行...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250507204836166.png" 
  alt="image-20250507204836166" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507204836166.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h2 id="init-函数和-import">Init 函数和 Import</h2>
<p>大家都知道 golang 里的 main 函数是程序的入口函数，main 函数返回后，程序也就结束了。golang 还有另外一个特殊的函数 init 函数，先于 main 函数执行，实现包级别的一些初始化操作。</p>
<h3 id="init-函数特点">init 函数特点</h3>
<p><code>init()</code> 函数的一个重要特点，便是其无需手动调用，它会在程序启动时自动执行。当程序开始运行时，Go 运行时系统会自动调用每个包中的 <code>init()</code> 函数。下面是一个示例代码，演示了 <code>init()</code> 函数在程序启动时自动执行的特点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Init function executed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Main function executed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这个示例代码中，我们定义了一个 <code>init()</code> 函数和一个 <code>main()</code> 函数。<code>init()</code> 函数会在程序启动时自动执行，而 <code>main()</code> 函数则是程序的入口函数，会在 <code>init()</code> 函数执行完毕后执行。输出如下：</p>
<pre tabindex="0"><code>Init function executed
Main function executed
</code></pre><p>可以看到，<code>init()</code> 函数在程序启动时自动执行，并且在 <code>main()</code> 函数之前被调用。这证明了 <code>init()</code> 函数在程序启动时会自动执行，可以用于在程序启动前进行一些必要的初始化操作。如初始化数据库的连接、载入本地配置文件、根据命令行参数初始化全局变量等。</p>
<p>init 是一个非常特殊的函数，之所以特殊，是因为有如下特点：</p>
<ul>
<li>init 函数是可选的，可以没有；</li>
<li>与 main 函数一样，不能有入参与返回值；</li>
<li>与 main 函数一样，init 会自动执行，不能被其他函数调用；</li>
<li>一个包内可以有多个 init 函数，即可以在包的多个源文件中定义多个 init 函数。一般建议在与包同名源文件中写一个 init 函数，这样可读性好且便于维护；</li>
<li>一个源文件可以有多个 init 函数。</li>
</ul>
<h3 id="import-导入规则">import 导入规则</h3>
<p>1、Go 以 <code>go.mod</code> 所在目录为模块根目录</p>
<p>2、模块外的代码不会自动包含进来，在 Go 语言里，每个 <code>go.mod</code> 定义了一个独立的 Go 模块，它会把 <code>go.mod</code> 所在目录及其子目录 视为 模块的一部分，而 不会自动包含 <code>go.mod</code> 目录外的代码。</p>
<p>3、包的导入路径必须从 <code>go.mod</code> 定义的 <code>module</code> 名称开始</p>
<p>如果整个项目路径是这样的：</p>
<pre tabindex="0"><code>awesomeProject2/   # 🚀 这是整个项目的根目录
├── go.mod         # ✅ go.mod 在根目录
├── initMain/      # main.go 在这里
│   ├── main.go
├── InitLib1/      # 这是一个 Go 包
│   ├── init.go
│   └── utils.go
</code></pre><p>go.mod 在根目录下，那么 go.mod 文件就定义了模块的名称，内容如下：</p>
<pre tabindex="0"><code>module awesomeProject2

go 1.20
</code></pre><p>然后，在 main.go 文件里面如下写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;awesomeProject2/InitLib1&#34;</span> <span class="c1">// ✅ 可以正确找到 InitLib1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>✅ 这样是没问题的，因为：</p>
<ul>
<li><code>go.mod</code> 在根目录，它的模块范围是 <code>awesomeProject2/</code> 以及其所有子目录。</li>
<li><code>InitLib1/</code> 是 <code>awesomeProject2/</code> 的子目录，所以 可以正确导入 <code>awesomeProject2/InitLib1</code>。</li>
</ul>
<p>❌ 如果 <code>go.mod</code> 在 <code>initMain/</code></p>
<p>现在，我们 把 <code>go.mod</code> 移到 <code>initMain/</code> 里面，也就是执行如下命令：</p>
<pre tabindex="0"><code>cd initMain
go mod init initMain
</code></pre><p>新的目录结构变成了：</p>
<pre tabindex="0"><code>awesomeProject2/   # ❌ 这里已经不是 Go 模块的根目录了
├── initMain/      # ✅ Go 现在把 initMain/ 当作模块的根目录
│   ├── go.mod
│   ├── main.go
├── InitLib1/      # ❌ 这个目录不在 initMain/ 里面
│   ├── init.go
│   └── utils.go
</code></pre><p>新的 <code>go.mod</code> 变成：</p>
<pre tabindex="0"><code>module initMain

go 1.20
</code></pre><p>然后 <code>main.go</code> 仍然尝试这样导入：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;initMain/InitLib1&#34;</span> <span class="c1">// ❌ 这里找不到 InitLib1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>运行 <code>go run main.go</code> 会报错：</p>
<pre tabindex="0"><code>cannot find module for import &#34;initMain/InitLib1&#34;
</code></pre><p>🔴 发生错误的原因：</p>
<p>1、Go 只会把 <code>go.mod</code> 目录（<code>initMain/</code>）及其子目录 视为模块的一部分。</p>
<p>2、<code>InitLib1/</code> 在 <code>initMain/</code> 目录外，所以 Go 不会自动包含它。</p>
<p>3、<code>import &quot;initMain/InitLib1&quot;</code> Go 找不到这个路径，因为 <code>InitLib1</code> 不在 <code>go.mod</code> 所定义的模块范围内。</p>
<p>🚀 解决方案：</p>
<p>1、方案一：改变目录机构，将 <code>InitLib1</code> 文件目录移动到 <code>initMain</code> 目录底下去</p>
<p>2、方案二：使用 replace，将 <code>initMain</code> 下的 go.mod 文件修改成如下：</p>
<pre tabindex="0"><code>module initMain

go 1.20

replace initMain/InitLib1 =&gt; ../InitLib1
</code></pre><p>这样 <code>go build</code> 才能找到 <code>InitLib1</code>，但这种方法很麻烦，不建议使用。</p>
<p>实际上，两个方案都不好，最好的方法就是 go.mod 放在 awesomeProject2 项目根目录底下。</p>
<h3 id="import-的执行顺序">import 的执行顺序</h3>
<p>程序的初始化和执行都起始于 main 包，如果 main 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到 fmt 包，但它只会被导入一次，因为没有必要导入多次）。</p>
<p>当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 init 函数（如果有的话），依次类推。</p>
<p>等所有被导入的包都加载完毕了，就会开始对 main 包中的包级常量和变量进行初始化，然后执行 main 包中的 init 函数（如果存在的话），最后执行 main 函数。下图详细地解释了整个执行过程：</p>
<p><img 
  src="./2025-0331-01/image-20250507212428903.png" 
  alt="image-20250507212428903" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507212428903.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>我们先看一下教学代码的目录结构：</p>
<p><img 
  src="./2025-0331-01/image-20250507212553095.png" 
  alt="image-20250507212553095" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507212553095.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>直接看代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">// Lib1.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">InitLib1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;lib1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">//Lib2.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">InitLib2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;lib2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">//main.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="s">&#34;awesomeProject2/InitLib1&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="s">&#34;awesomeProject2/InitLib2&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;libmain init&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;libmian main&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>lib1
lib2
libmain init
libmian main
</code></pre><p>输出的顺序与我们上面图给出的顺序是一致的。</p>
<p>那我们现在就改动一个地方，Lib1 包导入 Lib2，main 包不管</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">// Lib1.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">InitLib1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="s">&#34;awesomeProject2/InitLib2&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;lib1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>那么，改动后结果如下：</p>
<pre tabindex="0"><code>lib2
lib1
libmain init
libmian main
</code></pre><p>我们发现 main 包以及 Lib1 包都导入了 Lib2，但是只出现一次，并且最先输出，说明如果一个包会被多个包同时导入，那么它只会被导入一次，而先输出 lib2 是因为 main 包中导入 Lib1 时，Lib1 又导入了 Lib2，会首先初始化 Lib2 包的东西。</p>
<h3 id="import-匿名导入">import 匿名导入</h3>
<p>一路走来，你一定遇到过这样的情况：如果 import 的包没有使用，编译器就会报错。</p>
<p><img 
  src="./2025-0331-01/image-20250507213154956.png" 
  alt="image-20250507213154956" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507213154956.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>如果你直接编译上面的代码，会报错：./main.go:4:2: imported and not used: “fmt”</p>
<p>解决的方法有两种：</p>
<ul>
<li>注释或删除掉 import 语句</li>
<li>使用匿名导入（Blank Import）</li>
</ul>
<p>第一种没必要说，第二种也很简单，只需要改成如下，就可以绕过编译器的检查了。</p>
<p><img 
  src="./2025-0331-01/image-20250507213220275.png" 
  alt="image-20250507213220275" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507213220275.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>那么正常导入包和匿名导入包的区别是啥呢 ？？？</p>
<p>说到底，实际上 <code>import _ &quot;package&quot;</code> 语法就是用于 导入但不直接使用某个包。这样的导入方式不会让代码中直接调用这个包的函数或变量，但仍然会触发该包的 <code>init()</code> 函数执行。</p>
<blockquote>
<p><strong>匿名导入的作用</strong></p>
</blockquote>
<p>通常，导入一个包后，你可以直接使用它的函数、变量等：</p>
<p><img 
  src="./2025-0331-01/image-20250507214109411.png" 
  alt="image-20250507214109411" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507214109411.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>但有时你只想执行包的 <code>init()</code> 函数，而不需要使用包里的其他东西，这时就可以用 <code>_</code> 进行 匿名导入：</p>
<p><img 
  src="./2025-0331-01/image-20250507214126381.png" 
  alt="image-20250507214126381" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507214126381.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>这样做的效果：</p>
<ul>
<li><code>InitLib1</code> 包的 <code>init()</code> 会执行。</li>
<li>但 <code>InitLib1</code> 包里的 其他函数、变量不会被直接使用，也不会污染当前包的命名空间。</li>
</ul>
<blockquote>
<p><strong>匿名导入和普通导入的区别</strong></p>
</blockquote>
<p><strong>⚠️</strong> 普通导入（可以使用包内符号）</p>
<p><img 
  src="./2025-0331-01/image-20250507214155774.png" 
  alt="image-20250507214155774" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507214155774.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<ul>
<li><code>InitLib1</code> 里的 <code>init()</code> 会执行。</li>
<li><code>InitLib1</code> 里的 <code>SomeFunc()</code> 也能正常调用。</li>
</ul>
<p><strong>⚠️ <code>_</code> 导入（只执行 <code>init()</code>，不能使用包内符号）</strong></p>
<p><img 
  src="./2025-0331-01/image-20250507214222504.png" 
  alt="image-20250507214222504" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507214222504.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<ul>
<li><code>InitLib1</code> 里的 <code>init()</code> 会执行</li>
<li>但是不能直接调用 <code>InitLib1.SomeFunc()</code> ，因为 <code>_</code> 导入不会引入包内的符号。</li>
</ul>
<blockquote>
<p><strong>匿名导入适用场景</strong></p>
</blockquote>
<p>只想触发 <code>init()</code> 初始化，如果某个包里有重要的初始化逻辑，但你不需要用它的任何 API，可以用 <code>_</code> 导入：</p>
<p><img 
  src="./2025-0331-01/image-20250507214421707.png" 
  alt="image-20250507214421707" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507214421707.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<ul>
<li><code>sql</code> 包的 <code>init()</code> 会被执行，但 <code>sql</code> 里的 API 不能直接使用。</li>
<li><code>database/sql</code> 需要配合数据库驱动（例如 <code>mysql</code>），但不一定要直接使用 <code>sql</code> 包。</li>
</ul>
<p>用于注册机制，有些 Go 组件使用 插件机制，会在 <code>init()</code> 里自动注册自己。例如：</p>
<p><img 
  src="./2025-0331-01/image-20250507214510456.png" 
  alt="image-20250507214510456" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250507214510456.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<ul>
<li>这让 <code>image</code> 库自动支持 PNG 和 JPEG，即便代码中没直接调用 <code>png</code> 和 <code>jpeg</code>。</li>
<li><code>init()</code> 可能会调用 <code>image.RegisterFormat()</code>，这样 <code>image</code> 库就能解析 PNG/JPEG 了。</li>
</ul>
<h1 id="指针">指针</h1>
<p>Go语言中的指针不能进行偏移和运算，不同于C/C++中的指针，是安全指针。</p>
<h2 id="指针和指针变量区别">指针和指针变量区别</h2>
<p>指针实际是一个抽象的说法，是一个概念。而指针变量是一个具体的变量，是抽象的具体实现。</p>
<p>指针的本质是地址，表现在其本质就是一堆数字。指针变量本质是一个变量，只不过他内部存贮的是地址（即指针）。指针变量用来存放指针。</p>
<p>在 C/C++ 中，关于指针和指针变量比较严格的说是这样：</p>
<p>系统为每一个内存单元分配一个地址值，C/C++把这个地址值称为指针。如int i=5，存放变量i的内存单元的编号（地址）&amp;i 被称为指针。</p>
<p>指针变量则是存放前述地址值的变量，也可以表述为，指针变量是存放变量所占内存空间首地址的变量（因为一个变量通常要占用连续的多个字节空间）。</p>
<p>比如在 int i=5，后有一句 int *p=&amp;i，就把i的指针 &amp;i 赋给了 int * 型指针变量 p，也就是说 p 中存入着 &amp;i。所以说指针变量是存放指针的变量。</p>
<p>有一个事实值得注意，那就是有不少资料和教科书并没有如上区分，而是认为指针是指针变量的简称，如对 int *p=&amp;i 的解释是：</p>
<p>声明一个 int * 型指针p，并用变量 i 的地址初始化，而严格说应该是声明一个 int * 型指针变量 p 才对。所以有时看书要根据上下文理解实质，而不能过于拘泥于文字表述。</p>
<h2 id="指针声明和初始化">指针声明和初始化</h2>
<p>在 Go 语言中，可以使用指针来引用任何类型的变量。指针的声明和初始化可以通过如下语法完成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"> <span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="kt">int</span>  <span class="c1">// 声明一个指向 int 类型的指针 p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="kd">var</span> <span class="nx">str</span> <span class="o">*</span><span class="kt">string</span>  <span class="c1">// 声明一个指向 string 类型的指针 str
</span></span></span></code></pre></div><p>我们来看一个简单代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">a</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">10</span>	<span class="c1">// int 类型变量a存储了一个值 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="kt">int</span> <span class="c1">// 定义 int 类型指针变量 p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">a</span> <span class="c1">// 让指针 p 存储变量 a 的地址，也就是指针指向了a的这个地址。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;变量 a 的值: %d\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;变量 a 的地址: %p\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;指针 p 存储的地址: %p\n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>				<span class="c1">//或者说，指针p指向的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;通过指针 p 访问变量 a 的值: %d\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> 	<span class="c1">// 解引用指针，通过解引用，访问指针指向地址上的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>上面是用了 <code>var p *int</code> 定义的指针变量，实际上用 <code>p := &amp;num</code> 这样的方式定义指针变量更常见。</p>
<h2 id="指针的传递">指针的传递</h2>
<p>在前面了解值类型和引用类型的时候，我们知道指针是引用类型，那么指针是如何传递的呢 ？如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">modifyPointerValue</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;指针变量p:&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>     	 <span class="c1">//p是指针变量，实际就是一个变量的内存地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;通过指针p访问的值:&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">//内存地址对应的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">100</span>                      <span class="c1">// 将值改成100
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">num</span> <span class="o">:=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;变量 num 的地址: %p\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">modifyPointerValue</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">num</span><span class="p">)</span>                      <span class="c1">// 传递 num 的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;After modifyPointerValue:&#34;</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span> <span class="c1">// 100
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250511210327701.png" 
  alt="image-20250511210327701" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250511210327701.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>我们再来看一下下面的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">changePointer</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="o">:=</span> <span class="mi">200</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;changePointer中变量x的地址 %p\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;传入changePointer的地址&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;经过修改后指针p指向的地址&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">num</span> <span class="o">:=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">num</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;通过指针p访问的值&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;指针p指向的内存地址&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="c1">// 0xc00000a0e8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nf">changePointer</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// 这里传递的是 p 的拷贝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;执行完changePointer后，指针p指向的地址&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>    <span class="c1">// 0xc00000a0e8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;执行完changePointer后，通过指针p访问的值:&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// 仍然是 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250516202023095.png" 
  alt="image-20250516202023095" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250516202023095.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h2 id="new-和-make">New 和 Make</h2>
<p>我们先来看一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">a</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">b</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">[</span><span class="s">&#34;沙河娜扎&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>执行上面的代码会引发panic，为什么呢？</p>
<p>在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。</p>
<p>对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来new和make。</p>
<p>Go语言中new和make是内建的两个函数，主要用来分配内存。</p>
<blockquote>
<p><strong>New</strong></p>
</blockquote>
<p>new是一个内置的函数，它的函数签名如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Type</span><span class="p">)</span> <span class="o">*</span><span class="nx">Type</span>
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li>
<li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li>
</ul>
<p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="c1">// *int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">// *bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">a</span><span class="p">)</span>       <span class="c1">// 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">b</span><span class="p">)</span>       <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>	
</span></span></code></pre></div><p>本节开始的示例代码中<code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">a</span> <span class="p">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>make</strong></p>
</blockquote>
<p>make也是用于内存分配的，区别于new，它只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。</p>
<p>make函数的函数签名如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nb">make</span><span class="p">(</span><span class="nx">t</span> <span class="nx">Type</span><span class="p">,</span> <span class="nx">size</span> <span class="o">...</span><span class="nx">IntegerType</span><span class="p">)</span> <span class="nx">Type</span>
</span></span></code></pre></div><p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。</p>
<p>本节开始的示例中<code>var b map[string]int</code>只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">b</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">[</span><span class="s">&#34;沙河娜扎&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>new与make的区别</strong></p>
</blockquote>
<ul>
<li>二者都是用来做内存分配的。</li>
<li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li>
<li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li>
</ul>
<h1 id="结构体">结构体</h1>
<h2 id="类型别名和自定义类型">类型别名和自定义类型</h2>
<h3 id="自定义类型">自定义类型</h3>
<p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p>
<p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">//将MyInt定义为int类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">MyInt</span> <span class="kt">int</span>
</span></span></code></pre></div><p>通过<code>type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性。</p>
<h3 id="类型别名">类型别名</h3>
<p>类型别名是<code>Go1.9</code>版本添加的新功能。</p>
<p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<pre tabindex="0"><code>type TypeAlias = Type
</code></pre><p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p>
<h3 id="类型定义和别名的区别">类型定义和别名的区别</h3>
<p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p>
<pre tabindex="0"><code>//类型定义
type NewInt int

//类型别名
type MyInt = int

func main() {
	var a NewInt
	var b MyInt
	
	fmt.Printf(&#34;type of a:%T\n&#34;, a) //type of a:main.NewInt
	fmt.Printf(&#34;type of b:%T\n&#34;, b) //type of b:int
}
</code></pre><p>结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p>
<h2 id="结构体-1">结构体</h2>
<p>我们知道在 go 中是没有面向对象这样的概念的，但在实际的开发中，为了提高代码可读性、可扩展性和可复用性等特点，我们必须要使用面向对象的设计理念来编码。</p>
<p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了。</p>
<h3 id="结构体定义">结构体定义</h3>
<p>结构体（Struct）是一种自定义数据类型，用于组织和存储一组相关字段的集合。它类似于其他编程语言中的类或对象，是一种将数据和相关方法组合在一起的容器。</p>
<ul>
<li>结构体的字段就类似于面向对象中的属性。</li>
<li>结构体的方法就类似于面向对象中的方法。</li>
</ul>
<p>我们可以使用<code>type</code>和<code>struct</code>关键字来定义结构体，以此实现 <code>类</code>的效果，具体代码格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">类型名</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">字段名</span> <span class="nx">字段类型</span>
</span></span><span class="line"><span class="cl">    <span class="nx">字段名</span> <span class="nx">字段类型</span>
</span></span><span class="line"><span class="cl">    <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段类型：表示结构体字段的具体类型。</li>
</ul>
<p>举个例子，我们定义一个<code>Person</code>（人）结构体，代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">city</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">age</span>  <span class="kt">int8</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样我们就拥有了一个<code>person</code>的自定义类型，它有<code>name</code>、<code>city</code>、<code>age</code>三个字段，分别表示姓名、城市和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p>
<h3 id="结构体实例化">结构体实例化</h3>
<p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p>
<p>结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">结构体实例</span> <span class="nx">结构体类型</span>
</span></span></code></pre></div><blockquote>
<p><strong>基本实例化</strong></p>
</blockquote>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">city</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">age</span>  <span class="kt">int8</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">p1</span> <span class="nx">person</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p1</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;沙河娜扎&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p1</span><span class="p">.</span><span class="nx">city</span> <span class="p">=</span> <span class="s">&#34;北京&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p1</span><span class="p">.</span><span class="nx">age</span> <span class="p">=</span> <span class="mi">18</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;p1=%v\n&#34;</span><span class="p">,</span> <span class="nx">p1</span><span class="p">)</span>  <span class="c1">//p1={沙河娜扎 北京 18}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;p1=%#v\n&#34;</span><span class="p">,</span> <span class="nx">p1</span><span class="p">)</span> <span class="c1">//p1=main.person{name:&#34;沙河娜扎&#34;, city:&#34;北京&#34;, age:18}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>我们通过<code>.</code>来访问结构体的字段（成员变量）,例如<code>p1.name</code>和<code>p1.age</code>等。</p>
<blockquote>
<p><strong>匿名结构体</strong></p>
</blockquote>
<p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">     
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">     
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">user</span> <span class="kd">struct</span><span class="p">{</span><span class="nx">Name</span> <span class="kt">string</span><span class="p">;</span> <span class="nx">Age</span> <span class="kt">int</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">user</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;小王子&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">user</span><span class="p">.</span><span class="nx">Age</span> <span class="p">=</span> <span class="mi">18</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>创建指针类型的结构体</strong></p>
</blockquote>
<p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">p2</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">p2</span><span class="p">)</span>     <span class="c1">//*main.person
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;p2=%#v\n&#34;</span><span class="p">,</span> <span class="nx">p2</span><span class="p">)</span> <span class="c1">//p2=&amp;main.person{name:&#34;&#34;, city:&#34;&#34;, age:0}
</span></span></span></code></pre></div><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p>
<p>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">p2</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">p2</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;小王子&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">p2</span><span class="p">.</span><span class="nx">age</span> <span class="p">=</span> <span class="mi">28</span>
</span></span><span class="line"><span class="cl"><span class="nx">p2</span><span class="p">.</span><span class="nx">city</span> <span class="p">=</span> <span class="s">&#34;上海&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;p2=%#v\n&#34;</span><span class="p">,</span> <span class="nx">p2</span><span class="p">)</span> <span class="c1">//p2=&amp;main.person{name:&#34;小王子&#34;, city:&#34;上海&#34;, age:28}
</span></span></span></code></pre></div><blockquote>
<p><strong>取结构体的地址实例化</strong></p>
</blockquote>
<p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">p3</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">person</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">p3</span><span class="p">)</span>     <span class="c1">//*main.person
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;p3=%#v\n&#34;</span><span class="p">,</span> <span class="nx">p3</span><span class="p">)</span> <span class="c1">//p3=&amp;main.person{name:&#34;&#34;, city:&#34;&#34;, age:0}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">p3</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="s">&#34;七米&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">p3</span><span class="p">.</span><span class="nx">age</span> <span class="p">=</span> <span class="mi">30</span>
</span></span><span class="line"><span class="cl"><span class="nx">p3</span><span class="p">.</span><span class="nx">city</span> <span class="p">=</span> <span class="s">&#34;成都&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;p3=%#v\n&#34;</span><span class="p">,</span> <span class="nx">p3</span><span class="p">)</span> <span class="c1">//p3=&amp;main.person{name:&#34;七米&#34;, city:&#34;成都&#34;, age:30}
</span></span></span></code></pre></div><p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法。</p>
<h3 id="结构体初始化">结构体初始化</h3>
<p>没有初始化的结构体，其成员变量都是对应其类型的零值。如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">city</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">age</span>  <span class="kt">int8</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">p4</span> <span class="nx">person</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;p4=%#v\n&#34;</span><span class="p">,</span> <span class="nx">p4</span><span class="p">)</span> <span class="c1">//p4=main.person{name:&#34;&#34;, city:&#34;&#34;, age:0}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>使用键值对初始化</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">p5</span> <span class="o">:=</span> <span class="nx">person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span><span class="p">:</span> <span class="s">&#34;小王子&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">city</span><span class="p">:</span> <span class="s">&#34;北京&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">age</span><span class="p">:</span>  <span class="mi">18</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;p5=%#v\n&#34;</span><span class="p">,</span> <span class="nx">p5</span><span class="p">)</span> <span class="c1">//p5=main.person{name:&#34;小王子&#34;, city:&#34;北京&#34;, age:18}
</span></span></span></code></pre></div><p>也可以对结构体指针进行键值对初始化，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">p6</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span><span class="p">:</span> <span class="s">&#34;小王子&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">city</span><span class="p">:</span> <span class="s">&#34;北京&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="nx">age</span><span class="p">:</span>  <span class="mi">18</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;p6=%#v\n&#34;</span><span class="p">,</span> <span class="nx">p6</span><span class="p">)</span> <span class="c1">//p6=&amp;main.person{name:&#34;小王子&#34;, city:&#34;北京&#34;, age:18}
</span></span></span></code></pre></div><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">p7</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">city</span><span class="p">:</span> <span class="s">&#34;北京&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;p7=%#v\n&#34;</span><span class="p">,</span> <span class="nx">p7</span><span class="p">)</span> <span class="c1">//p7=&amp;main.person{name:&#34;&#34;, city:&#34;北京&#34;, age:0}
</span></span></span></code></pre></div><blockquote>
<p><strong>使用值的列表初始化</strong></p>
</blockquote>
<p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">p8</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;沙河娜扎&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;北京&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="mi">28</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;p8=%#v\n&#34;</span><span class="p">,</span> <span class="nx">p8</span><span class="p">)</span> <span class="c1">//p8=&amp;main.person{name:&#34;沙河娜扎&#34;, city:&#34;北京&#34;, age:28}
</span></span></span></code></pre></div><p>使用这种格式初始化时，需要注意：</p>
<ul>
<li>必须初始化结构体的所有字段。</li>
<li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li>
<li>该方式不能和键值初始化方式混用。</li>
</ul>
<h3 id="构造函数">构造函数</h3>
<p>构造函数用来封装初始化逻辑，初始化对象实例，go 语言中显然没有所谓的构造函数，我们可以自己实现。</p>
<p>我们先来看一下不使用构造函数的情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Age</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;Alice&#34;</span><span class="p">,</span> <span class="nx">Age</span><span class="p">:</span> <span class="mi">25</span><span class="p">}</span>	<span class="c1">//初始化声明结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// 输出: {Alice 25}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>使用构造函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Age</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewPerson</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">age</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">Person</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">Age</span><span class="p">:</span> <span class="nx">age</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span> <span class="o">:=</span> <span class="nf">NewPerson</span><span class="p">(</span><span class="s">&#34;Alice&#34;</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// 输出: {Alice 25}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>我们前面了解过结构体是值传递，在值传递的时候，会把结构体变量拷贝一份，如果结构体很大，就导致性能损耗，所以一般在写构造函数的时候推荐使用指针传递。例如如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Age</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">NewPerson</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">age</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Person</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">Age</span><span class="p">:</span> <span class="nx">age</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="o">:=</span> <span class="nf">NewPerson</span><span class="p">(</span><span class="s">&#34;Bob&#34;</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// 输出: {Bob 30}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250519202235810.png" 
  alt="image-20250519202235810" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250519202235810.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h3 id="方法值方法指针方法">方法（值方法、指针方法）</h3>
<p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p>
<p>我们在前面学习过定义结构体，也就是定义了一个<code>类</code>，那么有了类后，我们还需要一个方法。为什么要定义一个方法 ？</p>
<p>定义方法的主要目的是<strong>让结构体（struct）具有行为</strong>，<strong>让结构体（struct）不仅能存数据，还能执行行为</strong>，就像 “<strong>人不仅有名字和年龄，还能说话和走路</strong>”。</p>
<p>方法的定义格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">接收者</span> <span class="nx">结构体类型</span><span class="p">)</span> <span class="nx">方法名</span><span class="p">(</span><span class="nx">参数列表</span><span class="p">)</span> <span class="p">(</span><span class="nx">返回值列表</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 方法体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><pre tabindex="0"><code>func (接收者 *结构体类型) 方法名(参数列表) (返回值列表) {
    // 方法体
}
</code></pre><p>那么，上面两个方法的定义有啥区别呢 ？</p>
<ul>
<li>第一个（值方法）：<code>结构体类型</code>（传入的是结构体的副本，结构体中的任何修改操作，都不会影响原结构体数据，即，这个方法操作的是结构体的一个<strong>拷贝</strong>）</li>
<li>第二个（指针方法）：<code>*结构体类型</code>（传入的是结构体的指针，因此可以直接修改结构体的原始数据）</li>
</ul>
<p>我们直接来看两个demo：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Age</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 方法使用值接收者（不会修改原数据）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="nf">GrowOlder</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span><span class="p">.</span><span class="nx">Age</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Inside method:&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Age</span><span class="p">)</span> <span class="c1">// 输出：Inside method: 26
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;Alice&#34;</span><span class="p">,</span> <span class="nx">Age</span><span class="p">:</span> <span class="mi">25</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span><span class="p">.</span><span class="nf">GrowOlder</span><span class="p">()</span> <span class="c1">// 调用方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 输出：25，因为值接收者不会修改原始数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Outside method:&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Age</span><span class="p">)</span> <span class="c1">// 输出：Outside method: 25
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Age</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 方法使用指针接收者（会修改原数据）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Person</span><span class="p">)</span> <span class="nf">GrowOlder</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span><span class="p">.</span><span class="nx">Age</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Inside method:&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Age</span><span class="p">)</span> <span class="c1">// 输出：Inside method: 26
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;Alice&#34;</span><span class="p">,</span> <span class="nx">Age</span><span class="p">:</span> <span class="mi">25</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span><span class="p">.</span><span class="nf">GrowOlder</span><span class="p">()</span> <span class="c1">// 调用方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 输出：26，因为指针接收者修改了原始数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Outside method:&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Age</span><span class="p">)</span> <span class="c1">// 输出：Outside method: 26
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="结构体匿名字段">结构体匿名字段</h3>
<p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">//Person 结构体Person类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p1</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="s">&#34;小王子&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="mi">18</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">p1</span><span class="p">)</span>        <span class="c1">//main.Person{string:&#34;北京&#34;, int:18}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">p1</span><span class="p">.</span><span class="kt">string</span><span class="p">,</span> <span class="nx">p1</span><span class="p">.</span><span class="kt">int</span><span class="p">)</span> <span class="c1">//北京 18
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>**注意：**这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>
<h3 id="结构体嵌套">结构体嵌套</h3>
<p>一个结构体中可以嵌套包含另一个结构体或结构体指针，就像下面的示例代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//Address 地址结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Address</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Province</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">City</span>     <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//User 用户结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span>    <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Gender</span>  <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Address</span> <span class="nx">Address</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">user1</span> <span class="o">:=</span> <span class="nx">User</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Name</span><span class="p">:</span>   <span class="s">&#34;小王子&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Gender</span><span class="p">:</span> <span class="s">&#34;男&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Address</span><span class="p">:</span> <span class="nx">Address</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Province</span><span class="p">:</span> <span class="s">&#34;山东&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">City</span><span class="p">:</span>     <span class="s">&#34;威海&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;user1=%#v\n&#34;</span><span class="p">,</span> <span class="nx">user1</span><span class="p">)</span><span class="c1">//user1=main.User{Name:&#34;小王子&#34;, Gender:&#34;男&#34;, Address:main.Address{Province:&#34;山东&#34;, City:&#34;威海&#34;}}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>嵌套匿名字段</strong></p>
</blockquote>
<p>上面user结构体中嵌套的<code>Address</code>结构体也可以采用匿名字段的方式，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">//Address 地址结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Address</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Province</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">City</span>     <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//User 用户结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span>    <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Gender</span>  <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Address</span> <span class="c1">//匿名字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">user2</span> <span class="nx">User</span>
</span></span><span class="line"><span class="cl">	<span class="nx">user2</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;小王子&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">user2</span><span class="p">.</span><span class="nx">Gender</span> <span class="p">=</span> <span class="s">&#34;男&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">user2</span><span class="p">.</span><span class="nx">Address</span><span class="p">.</span><span class="nx">Province</span> <span class="p">=</span> <span class="s">&#34;山东&#34;</span>    <span class="c1">// 匿名字段默认使用类型名作为字段名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">user2</span><span class="p">.</span><span class="nx">City</span> <span class="p">=</span> <span class="s">&#34;威海&#34;</span>                <span class="c1">// 匿名字段可以省略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;user2=%#v\n&#34;</span><span class="p">,</span> <span class="nx">user2</span><span class="p">)</span> <span class="c1">//user2=main.User{Name:&#34;小王子&#34;, Gender:&#34;男&#34;, Address:main.Address{Province:&#34;山东&#34;, City:&#34;威海&#34;}}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。</p>
<blockquote>
<p><strong>嵌套结构体的字段名冲突</strong></p>
</blockquote>
<p>嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//Address 地址结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Address</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Province</span>   <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">City</span>       <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">CreateTime</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//Email 邮箱结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Email</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Account</span>    <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">CreateTime</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//User 用户结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span>   <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Gender</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Address</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Email</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">user3</span> <span class="nx">User</span>
</span></span><span class="line"><span class="cl">	<span class="nx">user3</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;沙河娜扎&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">user3</span><span class="p">.</span><span class="nx">Gender</span> <span class="p">=</span> <span class="s">&#34;男&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// user3.CreateTime = &#34;2019&#34; //ambiguous selector user3.CreateTime
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">user3</span><span class="p">.</span><span class="nx">Address</span><span class="p">.</span><span class="nx">CreateTime</span> <span class="p">=</span> <span class="s">&#34;2000&#34;</span> <span class="c1">//指定Address结构体中的CreateTime
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">user3</span><span class="p">.</span><span class="nx">Email</span><span class="p">.</span><span class="nx">CreateTime</span> <span class="p">=</span> <span class="s">&#34;2000&#34;</span>   <span class="c1">//指定Email结构体中的CreateTime
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="结构体的继承">结构体的继承</h3>
<p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">//Animal 动物
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Animal</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">Animal</span><span class="p">)</span> <span class="nf">move</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s会动！\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//Dog 狗
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Feet</span>    <span class="kt">int8</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">Animal</span> <span class="c1">//通过嵌套匿名结构体实现继承
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nf">wang</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s会汪汪汪~\n&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Dog</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Feet</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Animal</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">Animal</span><span class="p">{</span> <span class="c1">//注意嵌套的是结构体指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">name</span><span class="p">:</span> <span class="s">&#34;乐乐&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">},</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d1</span><span class="p">.</span><span class="nf">wang</span><span class="p">()</span> <span class="c1">//乐乐会汪汪汪~
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">d1</span><span class="p">.</span><span class="nf">move</span><span class="p">()</span> <span class="c1">//乐乐会动！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="结构体的可见字段">结构体的可见字段</h3>
<p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p>
<h3 id="结构体与json序列化">结构体与JSON序列化</h3>
<p>JSON是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">//Student 学生
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Student</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ID</span>     <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Gender</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span>   <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//Class 班级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Class</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Title</span>    <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Students</span> <span class="p">[]</span><span class="nx">Student</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Class</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Title</span><span class="p">:</span>    <span class="s">&#34;101&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Students</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Student</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">stu</span> <span class="o">:=</span> <span class="nx">Student</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Name</span><span class="p">:</span>   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;stu%02d&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Gender</span><span class="p">:</span> <span class="s">&#34;男&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ID</span><span class="p">:</span>     <span class="nx">i</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">Students</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Students</span><span class="p">,</span> <span class="nx">stu</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//JSON序列化：结构体--&gt;JSON格式的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;json marshal failed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;json:%s\n&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">//JSON反序列化：JSON格式的字符串--&gt;结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">str</span> <span class="o">:=</span> <span class="s">`{&#34;Title&#34;:&#34;101&#34;,&#34;Students&#34;:[{&#34;ID&#34;:0,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu00&#34;},{&#34;ID&#34;:1,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu01&#34;},{&#34;ID&#34;:2,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu02&#34;},{&#34;ID&#34;:3,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu03&#34;},{&#34;ID&#34;:4,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu04&#34;},{&#34;ID&#34;:5,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu05&#34;},{&#34;ID&#34;:6,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu06&#34;},{&#34;ID&#34;:7,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu07&#34;},{&#34;ID&#34;:8,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu08&#34;},{&#34;ID&#34;:9,&#34;Gender&#34;:&#34;男&#34;,&#34;Name&#34;:&#34;stu09&#34;}]}`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Class</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="p">=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">str</span><span class="p">),</span> <span class="nx">c1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;json unmarshal failed!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">c1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="结构体标签tag">结构体标签Tag</h3>
<p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，具体的格式如下：</p>
<pre tabindex="0"><code>`key1:&#34;value1&#34; key2:&#34;value2&#34;`
</code></pre><p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p>
<p><strong>注意事项：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p>
<p>例如我们为<code>Student</code>结构体的每个字段定义json序列化时使用的Tag：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//Student 学生
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Student</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ID</span>     <span class="kt">int</span>    <span class="s">`json:&#34;id&#34;`</span> <span class="c1">//通过指定tag实现json序列化该字段时的key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Gender</span> <span class="kt">string</span> <span class="c1">//json序列化是默认使用字段名作为key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">name</span>   <span class="kt">string</span> <span class="c1">//私有不能被json包访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s1</span> <span class="o">:=</span> <span class="nx">Student</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ID</span><span class="p">:</span>     <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Gender</span><span class="p">:</span> <span class="s">&#34;男&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">name</span><span class="p">:</span>   <span class="s">&#34;沙河娜扎&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;json marshal failed!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;json str:%s\n&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="c1">//json str:{&#34;id&#34;:1,&#34;Gender&#34;:&#34;男&#34;}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h1 id="包管理">包管理</h1>
<h1 id="接口">接口</h1>
<p>在Go语言中接口（interface）是一种类型，一种抽象的类型。相较于之前章节中讲到的那些具体类型（字符串、切片、结构体等）更注重“我是谁”，接口类型更注重“我能做什么”的问题。</p>
<p>接口类型就像是一种约定——概括了一种类型应该具备哪些方法，在Go语言中提倡使用面向接口的编程方式实现解耦。</p>
<h2 id="接口类型">接口类型</h2>
<p>接口是一种由程序员来定义的类型，一个接口类型就是一组方法的集合，它规定了需要实现的所有方法。</p>
<p>相较于使用结构体类型，当我们使用接口类型说明相比于它是什么更关心它能做什么。</p>
<h3 id="接口定义">接口定义</h3>
<p>每个接口类型由任意个方法签名组成，接口的定义格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">接口类型名</span> <span class="kd">interface</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">方法名1</span><span class="p">(</span> <span class="nx">参数列表1</span> <span class="p">)</span> <span class="nx">返回值列表1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">方法名2</span><span class="p">(</span> <span class="nx">参数列表2</span> <span class="p">)</span> <span class="nx">返回值列表2</span>
</span></span><span class="line"><span class="cl">    <span class="err">…</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>接口类型名：Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有关闭操作的接口叫<code>closer</code>等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li>
</ul>
<p>举个例子，定义一个包含<code>Write</code>方法的<code>Writer</code>接口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Write</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当你看到一个<code>Writer</code>接口类型的值时，你不知道它是什么，唯一知道的就是可以通过调用它的<code>Write</code>方法来做一些事情。</p>
<h3 id="实现接口的条件">实现接口的条件</h3>
<p>接口就是规定了一个<strong>需要实现的方法列表</strong>，在 Go 语言中一个类型只要实现了接口中规定的所有方法，那么我们就称它实现了这个接口。</p>
<p>我们定义的<code>Singer</code>接口类型，它包含一个<code>Sing</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">// Singer 接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Singer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Sing</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们有一个<code>Bird </code>结构体类型如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Bird</span> <span class="kd">struct</span> <span class="p">{}</span>
</span></span></code></pre></div><p>因为<code>Singer</code>接口只包含一个<code>Sing</code>方法，所以只需要给<code>Bird</code>结构体添加一个<code>Sing</code>方法就可以满足<code>Singer</code>接口的要求。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">// Sing Bird类型的Sing方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">Bird</span><span class="p">)</span> <span class="nf">Sing</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;汪汪汪&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样就称为<code>Bird</code>实现了<code>Singer</code>接口。</p>
<h3 id="为什么要使用接口">为什么要使用接口</h3>
<p>现在假设我们的代码世界里有很多小动物，下面的代码片段定义了猫和狗，它们饿了都会叫。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Cat</span><span class="p">)</span> <span class="nf">Say</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;喵喵喵~&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">Dog</span><span class="p">)</span> <span class="nf">Say</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;汪汪汪~&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">Cat</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Say</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">Dog</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nf">Say</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个时候又跑来了一只羊，羊饿了也会发出叫声。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Sheep</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Sheep</span><span class="p">)</span> <span class="nf">Say</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;咩咩咩~&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们接下来定义一个饿肚子的场景。</p>
<pre tabindex="0"><code>// MakeCatHungry 猫饿了会喵喵喵~
func MakeCatHungry(c Cat) {
	c.Say()
}

// MakeSheepHungry 羊饿了会咩咩咩~
func MakeSheepHungry(s Sheep) {
	s.Say()
}
</code></pre><p>接下来会有越来越多的小动物跑过来，我们的代码世界该怎么拓展呢？</p>
<p>在饿肚子这个场景下，我们可不可以把所有动物都当成一个“会叫的类型”来处理呢？当然可以！使用接口类型就可以实现这个目标。</p>
<p>我们的代码其实并不关心究竟是什么动物在叫，我们只是在代码中调用它的<code>Say()</code>方法，这就足够了。</p>
<p>我们可以约定一个<code>Sayer</code>类型，它必须实现一个<code>Say()</code>方法，只要饿肚子了，我们就调用<code>Say()</code>方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Sayer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Say</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>然后我们定义一个通用的<code>MakeHungry</code>函数，接收<code>Sayer</code>类型的参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">// MakeHungry 饿肚子了...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">MakeHungry</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Sayer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nf">Say</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们通过使用接口类型，把所有会叫的动物当成<code>Sayer</code>类型来处理，只要实现了<code>Say()</code>方法都能当成<code>Sayer</code>类型的变量来处理。(调用接口的方法？是否必须先定义一个接口类型的变量？不必须，不需要显式地定义一个接口变量，只要传入的类型实现了接口定义的方法，Go 编译器会自动将其“隐式转换”为接口类型。）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">c</span> <span class="nx">cat</span>
</span></span><span class="line"><span class="cl"><span class="nf">MakeHungry</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">d</span> <span class="nx">dog</span>
</span></span><span class="line"><span class="cl"><span class="nf">MakeHungry</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
</span></span></code></pre></div><p>在电商系统中我们允许用户使用多种支付方式（支付宝支付、微信支付、银联支付等），我们的交易流程中可能不太在乎用户究竟使用什么支付方式，只要它能提供一个实现支付功能的<code>Pay</code>方法让调用方调用就可以了。</p>
<p>再比如我们需要在某个程序中添加一个将某些指标数据向外输出的功能，根据不同的需求可能要将数据输出到终端、写入到文件或者通过网络连接发送出去。在这个场景下我们可以不关注最终输出的目的地是什么，只需要它能提供一个<code>Write</code>方法让我们把内容写入就可以了。</p>
<p>Go语言中为了解决类似上面的问题引入了接口的概念，接口类型区别于我们介绍的那些具体类型，让我们专注于该类型提供的方法，而不是类型本身。使用接口类型通常能够让我们写出更加通用和灵活的代码。</p>
<h3 id="面向接口编程">面向接口编程</h3>
<p>PHP、Java等语言中也有接口的概念，不过在PHP和Java语言中需要显式声明一个类实现了哪些接口，在Go语言中使用隐式声明的方式实现接口。只要一个类型实现了接口中规定的所有方法，那么它就实现了这个接口。</p>
<p>Go语言中的这种设计符合程序开发中抽象的一般规律，例如在下面的代码示例中，我们的电商系统最开始只设计了支付宝一种支付方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ZhiFuBao</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 支付宝
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Pay 支付宝的支付方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">z</span> <span class="o">*</span><span class="nx">ZhiFuBao</span><span class="p">)</span> <span class="nf">Pay</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;使用支付宝付款：%.2f元。\n&#34;</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">amount</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Checkout 结账
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Checkout</span><span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">ZhiFuBao</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">	<span class="c1">// 支付100元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">obj</span><span class="p">.</span><span class="nf">Pay</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Checkout</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ZhiFuBao</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>随着业务的发展，根据用户需求添加支持微信支付。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">WeChat</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 微信
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Pay 微信的支付方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">WeChat</span><span class="p">)</span> <span class="nf">Pay</span><span class="p">(</span><span class="nx">amount</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;使用微信付款：%.2f元。\n&#34;</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">amount</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在实际的交易流程中，我们可以根据用户选择的支付方式来决定最终调用支付宝的Pay方法还是微信支付的Pay方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Checkout 支付宝结账
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">CheckoutWithZFB</span><span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">ZhiFuBao</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 支付100元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">obj</span><span class="p">.</span><span class="nf">Pay</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Checkout 微信支付结账
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">CheckoutWithWX</span><span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">WeChat</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 支付100元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">obj</span><span class="p">.</span><span class="nf">Pay</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>实际上，从上面的代码示例中我们可以看出，我们其实并不怎么关心用户选择的是什么支付方式，我们只关心调用Pay方法时能否正常运行。这就是典型的“不关心它是什么，只关心它能做什么”的场景。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Payer 包含支付方法的接口类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Payer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Pay</span><span class="p">(</span><span class="kt">int64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>此时只需要修改下原始的<code>Checkout</code>函数，它接收一个<code>Payer</code>类型的参数。这样就能够在不修改既有函数调用的基础上，支持新的支付方式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Checkout 结账
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Checkout</span><span class="p">(</span><span class="nx">obj</span> <span class="nx">Payer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 支付100元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">obj</span><span class="p">.</span><span class="nf">Pay</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Checkout</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ZhiFuBao</span><span class="p">{})</span> <span class="c1">// 之前调用支付宝支付
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nf">Checkout</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">WeChat</span><span class="p">{})</span> <span class="c1">// 现在支持使用微信支付
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>像类似的例子在我们编程过程中会经常遇到：</p>
<ul>
<li>比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？</li>
<li>比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？</li>
<li>比如满减券、立减券、打折券都属于电商场景下常见的优惠方式，我们能不能把它们当成“优惠券”来处理呢？</li>
</ul>
<p>接口类型是Go语言提供的一种工具，在实际的编码过程中是否使用它由你自己决定，但是通常使用接口类型可以使代码更清晰易读。</p>
<h3 id="接口变量类型">接口变量类型</h3>
<p>那实现了接口又有什么用呢？一个接口类型的变量能够存储所有实现了该接口的类型变量 。</p>
<p>例如在上面的示例中，<code>Dog</code>和<code>Cat</code>类型均实现了<code>Sayer</code>接口，此时一个<code>Sayer</code>类型的变量就能够接收<code>Cat</code>和<code>Dog</code>类型的变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="nx">Sayer</span> <span class="c1">// 声明一个Sayer类型的变量x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">a</span> <span class="o">:=</span> <span class="nx">Cat</span><span class="p">{}</span>  <span class="c1">// 声明一个Cat类型变量a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">b</span> <span class="o">:=</span> <span class="nx">Dog</span><span class="p">{}</span>  <span class="c1">// 声明一个Dog类型变量b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">x</span> <span class="p">=</span> <span class="nx">a</span>       <span class="c1">// 可以把Cat类型变量直接赋值给x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">x</span><span class="p">.</span><span class="nf">Say</span><span class="p">()</span>     <span class="c1">// 喵喵喵
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">x</span> <span class="p">=</span> <span class="nx">b</span>       <span class="c1">// 可以把Dog类型变量直接赋值给x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">x</span><span class="p">.</span><span class="nf">Say</span><span class="p">()</span>     <span class="c1">// 汪汪汪
</span></span></span></code></pre></div><h3 id="值接收者和指针接收者">值接收者和指针接收者</h3>
<p>在结构体那部分中，我们介绍了在定义结构体方法时了解过值方法和指针方法的区别，那么对于实现接口来说使用值接收者和使用指针接收者有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 接口定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Changer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">SetName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">ShowName</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用值接收者实现接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">PersonValue</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">PersonValue</span><span class="p">)</span> <span class="nf">SetName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">name</span> <span class="c1">// 只是改了副本
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">PersonValue</span><span class="p">)</span> <span class="nf">ShowName</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;值接收者 name:&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用指针接收者实现接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">PersonPointer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">PersonPointer</span><span class="p">)</span> <span class="nf">SetName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">name</span> <span class="c1">// 修改了原始数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">PersonPointer</span><span class="p">)</span> <span class="nf">ShowName</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;指针接收者 name:&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;== 值接收者实现接口 ==&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">c1</span> <span class="nx">Changer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pv</span> <span class="o">:=</span> <span class="nx">PersonValue</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;Alice&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c1</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">pv</span>          <span class="c1">// 也可以是 c1 = pv ，因为值接收者实现了接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c1</span><span class="p">.</span><span class="nf">SetName</span><span class="p">(</span><span class="s">&#34;Eve&#34;</span><span class="p">)</span> <span class="c1">// 修改失败（值拷贝）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c1</span><span class="p">.</span><span class="nf">ShowName</span><span class="p">()</span>     <span class="c1">// 输出：Alice（没变）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;== 指针接收者实现接口 ==&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">c2</span> <span class="nx">Changer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PersonPointer</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;Bob&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c2</span> <span class="p">=</span> <span class="nx">pp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c2</span><span class="p">.</span><span class="nf">SetName</span><span class="p">(</span><span class="s">&#34;Tom&#34;</span><span class="p">)</span> <span class="c1">// 修改成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c2</span><span class="p">.</span><span class="nf">ShowName</span><span class="p">()</span>     <span class="c1">// 输出：Tom
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250608164333968.png" 
  alt="image-20250608164333968" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250608164333968.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>总结：</p>
<table>
<thead>
<tr>
<th>实现方式</th>
<th style="text-align:center">能否修改结构体字段</th>
<th>是否能赋值给接口变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>值接收者</td>
<td style="text-align:center">❌ 不行（改的是副本）</td>
<td>✅ 值和指针都能赋值</td>
</tr>
<tr>
<td>指针接收者</td>
<td style="text-align:center">✅ 可以修改字段</td>
<td>✅ 只能指针赋值</td>
</tr>
</tbody>
</table>
<h3 id="类型和接口的关系">类型和接口的关系</h3>
<blockquote>
<p><strong>一个类型实现多个接口</strong></p>
</blockquote>
<p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。例如狗不仅可以叫，还可以动。我们完全可以分别定义<code>Sayer</code>接口和<code>Mover</code>接口，具体代码示例如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Sayer 接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Sayer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Say</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Mover 接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Mover</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Move</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>Dog</code>既可以实现<code>Sayer</code>接口，也可以实现<code>Mover</code>接口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 实现Sayer接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">Dog</span><span class="p">)</span> <span class="nf">Say</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s会叫汪汪汪\n&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 实现Mover接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">Dog</span><span class="p">)</span> <span class="nf">Move</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s会动\n&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>同一个类型实现不同的接口互相不影响使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">d</span> <span class="p">=</span> <span class="nx">Dog</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;旺财&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s</span> <span class="nx">Sayer</span> <span class="p">=</span> <span class="nx">d</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">m</span> <span class="nx">Mover</span> <span class="p">=</span> <span class="nx">d</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">s</span><span class="p">.</span><span class="nf">Say</span><span class="p">()</span>  <span class="c1">// 对Sayer类型调用Say方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">m</span><span class="p">.</span><span class="nf">Move</span><span class="p">()</span> <span class="c1">// 对Mover类型调用Move方法
</span></span></span></code></pre></div><blockquote>
<p><strong>多种类型实现同一接口</strong></p>
</blockquote>
<p>Go语言中不同的类型还可以实现同一接口。例如在我们的代码世界中不仅狗可以动，汽车也可以动。（也就是多态：同一接口在不同类型上的不同实现）</p>
<p>我们可以使用如下代码体现上面的关系。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 实现Mover接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">Dog</span><span class="p">)</span> <span class="nf">Move</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s会动\n&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Car 汽车结构体类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Car</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Brand</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Move Car类型实现Mover接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">Car</span><span class="p">)</span> <span class="nf">Move</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s速度70迈\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Brand</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这样我们在代码中就可以把狗和汽车当成一个会动的类型来处理，不必关注它们具体是什么，只需要调用它们的<code>Move</code>方法就可以了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">obj</span> <span class="nx">Mover</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj</span> <span class="p">=</span> <span class="nx">Dog</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;旺财&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nf">Move</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">obj</span> <span class="p">=</span> <span class="nx">Car</span><span class="p">{</span><span class="nx">Brand</span><span class="p">:</span> <span class="s">&#34;宝马&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nf">Move</span><span class="p">()</span>
</span></span></code></pre></div><p>上面的代码执行结果如下：</p>
<pre tabindex="0"><code>旺财会跑
宝马速度70迈
</code></pre><p>个接口的所有方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// WashingMachine 洗衣机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">WashingMachine</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">wash</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">dry</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 甩干器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">dryer</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 实现WashingMachine接口的dry()方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="nx">dryer</span><span class="p">)</span> <span class="nf">dry</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;甩一甩&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 海尔洗衣机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">haier</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">dryer</span> <span class="c1">//嵌入甩干器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 实现WashingMachine接口的wash()方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">haier</span><span class="p">)</span> <span class="nf">wash</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;洗刷刷&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>一个类型要实现  wash()  和  dry() 两个方法，才算是实现了 WashingMachine 接口。结构体 dryer 结构体负责甩干（dry方法），haier 负责洗（wash方法），但是 haier 内嵌入了 dryer ，也就是等同于有了 dryer 的所有方法，就好像 haier 也有了 dry 一样，haier 就完整实现了 WashingMachine 接口。</p>
<p>##　结构体接口组合：结构体嵌套接口</p>
<p>结构体嵌套结构体前面我们已经了解过了，就是继承，但在实际的应用中，结构体嵌套接口也非常常见。</p>
<p>结构体嵌套接口的主要作用是 继承接口的功能，让结构体自动具备某种行为，同时还能扩展新功能。我们来看一个实际的例子：</p>
<p>日志系统增强：公司里已经有一个 <code>Logger</code> 接口，用于记录日志，如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Log</span><span class="p">(</span><span class="nx">message</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>现在，我们需要扩展这个日志系统，让日志支持 错误级别 (Error Level)，但不修改原有 <code>Logger</code> 代码。</p>
<p>如果我们直接 <code>Logger</code> 接口，可能会导致所有实现 <code>Logger</code> 的代码都要改：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Log</span><span class="p">(</span><span class="nx">message</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ErrorLog</span><span class="p">(</span><span class="nx">message</span> <span class="kt">string</span><span class="p">)</span> <span class="c1">// 破坏了原接口，老代码全得改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>这样就导致：所有用到 <code>Logger</code> 的地方都得改，影响范围太大。</p>
<p>我们可以创建一个 <code>AdvancedLogger</code> 结构体，嵌套 <code>Logger</code>，然后扩展功能</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 1️⃣ 原有的 Logger 接口（不能改）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Log</span><span class="p">(</span><span class="nx">message</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 2️⃣ 旧的日志实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">ConsoleLogger</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">ConsoleLogger</span><span class="p">)</span> <span class="nf">Log</span><span class="p">(</span><span class="nx">message</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;INFO:&#34;</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 3️⃣ 新的结构体嵌套接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">AdvancedLogger</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Logger</span> <span class="c1">// ⬅️ 这里嵌套了 Logger 接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 4️⃣ 扩展新的功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="nx">AdvancedLogger</span><span class="p">)</span> <span class="nf">ErrorLog</span><span class="p">(</span><span class="nx">message</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ERROR:&#34;</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 原始的日志功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">basicLogger</span> <span class="o">:=</span> <span class="nx">ConsoleLogger</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">basicLogger</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">&#34;System started&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 使用结构体嵌套接口，增强功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">advLogger</span> <span class="o">:=</span> <span class="nx">AdvancedLogger</span><span class="p">{</span><span class="nx">Logger</span><span class="p">:</span> <span class="nx">basicLogger</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">advLogger</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">&#34;System running&#34;</span><span class="p">)</span>   <span class="c1">// 继承 Logger 的功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">advLogger</span><span class="p">.</span><span class="nf">ErrorLog</span><span class="p">(</span><span class="s">&#34;System crash!&#34;</span><span class="p">)</span> <span class="c1">// 新增的功能
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250619203852558.png" 
  alt="image-20250619203852558" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250619203852558.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h2 id="接口组合接口嵌套接口">接口组合：接口嵌套接口</h2>
<p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库<code>io</code>源码中就有很多接口之间互相组合的示例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// src/io/io.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Closer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Reader</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Writer</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">ReadCloser</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Reader</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Closer</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">WriteCloser</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Writer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Closer</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p>
<h2 id="空接口">空接口</h2>
<h3 id="空接口的定义">空接口的定义</h3>
<p>空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 空接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Any 不包含任何方法的空接口类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Any</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Dog 狗结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">x</span> <span class="nx">Any</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="p">=</span> <span class="s">&#34;你好&#34;</span> <span class="c1">// 字符串型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type:%T value:%v\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="p">=</span> <span class="mi">100</span> <span class="c1">// int型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type:%T value:%v\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="p">=</span> <span class="kc">true</span> <span class="c1">// 布尔型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type:%T value:%v\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="p">=</span> <span class="nx">Dog</span><span class="p">{}</span> <span class="c1">// 结构体类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type:%T value:%v\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>通常我们在使用空接口类型时不必使用<code>type</code>关键字声明，可以像下面的代码一样直接使用<code>interface{}</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">x</span> <span class="kd">interface</span><span class="p">{}</span>  <span class="c1">// 声明一个空接口类型变量x
</span></span></span></code></pre></div><h3 id="空接口的应用">空接口的应用</h3>
<blockquote>
<p><strong>空接口作为函数的参数</strong></p>
</blockquote>
<p>使用空接口实现可以接收任意类型的函数参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 空接口作为函数参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">show</span><span class="p">(</span><span class="nx">a</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type:%T value:%v\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>空接口作为map的值</strong></p>
</blockquote>
<p>使用空接口实现可以保存任意值的字典。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">// 空接口作为map值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">studentInfo</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">studentInfo</span><span class="p">[</span><span class="s">&#34;name&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;沙河娜扎&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">studentInfo</span><span class="p">[</span><span class="s">&#34;age&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">18</span>
</span></span><span class="line"><span class="cl">	<span class="nx">studentInfo</span><span class="p">[</span><span class="s">&#34;married&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">studentInfo</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="接口值">接口值</h2>
<p>由于接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体<code>值</code>之外，还需要记录这个值属于的<code>类型</code>。也就是说接口值由“类型”和“值”组成，鉴于这两部分会根据存入值的不同而发生变化，我们称之为接口的<code>动态类型</code>和<code>动态值</code>。</p>
<p><img 
  src="./2025-0331-01/image-20250619205143548.png" 
  alt="image-20250619205143548" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250619205143548.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>我们接下来通过一个示例来加深对接口值的理解。</p>
<p>下面的示例代码中，定义了一个<code>Mover</code>接口类型和两个实现了该接口的<code>Dog</code>和<code>Car</code>结构体类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Mover</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Move</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Dog</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Dog</span><span class="p">)</span> <span class="nf">Move</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;狗在跑~&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Car</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Brand</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Car</span><span class="p">)</span> <span class="nf">Move</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;汽车在跑~&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>首先，我们创建一个<code>Mover</code>接口类型的变量<code>m</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">m</span> <span class="nx">Mover</span>
</span></span></code></pre></div><p>此时，接口变量<code>m</code>是接口类型的零值，也就是它的类型和值部分都是<code>nil</code>，就如下图所示。</p>
<p><img 
  src="./2025-0331-01/image-20250619205518545.png" 
  alt="image-20250619205518545" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250619205518545.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>我们可以使用<code>m == nil</code>来判断此时的接口值是否为空。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>  <span class="c1">// true
</span></span></span></code></pre></div><p><strong>注意</strong>：我们不能对一个空接口值调用任何方法，否则会产生panic。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">m</span><span class="p">.</span><span class="nf">Move</span><span class="p">()</span> <span class="c1">// panic: runtime error: invalid memory address or nil pointer dereference
</span></span></span></code></pre></div><p>接下来，我们将一个<code>*Dog</code>结构体指针赋值给变量<code>m</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">m</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Dog</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;旺财&#34;</span><span class="p">}</span>
</span></span></code></pre></div><p>此时，接口值<code>m</code>的动态类型会被设置为<code>*Dog</code>，动态值为结构体变量的拷贝。</p>
<p><img 
  src="./2025-0331-01/image-20250619205815816.png" 
  alt="image-20250619205815816" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250619205815816.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>然后，我们给接口变量<code>m</code>赋值为一个<code>*Car</code>类型的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">Car</span>
</span></span><span class="line"><span class="cl"><span class="nx">m</span> <span class="p">=</span> <span class="nx">c</span>
</span></span></code></pre></div><p>这一次，接口值<code>m</code>的动态类型为<code>*Car</code>，动态值为<code>nil</code>。</p>
<p><img 
  src="./2025-0331-01/image-20250619205850964.png" 
  alt="image-20250619205850964" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250619205850964.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p><strong>注意</strong>：此时接口变量<code>m</code>与<code>nil</code>并不相等，因为它只是动态值的部分为<code>nil</code>，而动态类型部分保存着对应值的类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">m</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="c1">// false
</span></span></span></code></pre></div><p>接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="nx">Mover</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Dog</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">y</span> <span class="nx">Mover</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Car</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span> <span class="o">==</span> <span class="nx">y</span><span class="p">)</span> <span class="c1">// false
</span></span></span></code></pre></div><p>但是有一种特殊情况需要特别注意，如果接口值保存的动态类型相同，但是这个动态类型不支持互相比较（比如切片），那么对它们相互比较时就会引发panic。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">z</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">z</span> <span class="o">==</span> <span class="nx">z</span><span class="p">)</span> <span class="c1">// panic: runtime error: comparing uncomparable type []int
</span></span></span></code></pre></div><h3 id="经典案例nil-不等于-nil">经典案例：nil 不等于 nil</h3>
<p>直接看代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;errors&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyError</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">error</span>	<span class="c1">//MyError 结构体嵌入了 error接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ErrBad</span> <span class="p">=</span> <span class="nx">MyError</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">error</span><span class="p">:</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;bad things happened&#34;</span><span class="p">),</span>	<span class="c1">//定义结构体 ErrBad，其中的 error: errors.New(&#34;bad things happened&#34;) 就是结构体初始化格式 键:值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">bad</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">returnsError</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="nx">MyError</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nf">bad</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">ErrBad</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">p</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nf">returnsError</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;error occur: %+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ok&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250619213612229.png" 
  alt="image-20250619213612229" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250619213612229.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>当理解了上面接口值中的内容，就很容易理解上面的输出结果为啥不是 ok 了。</p>
<p>如果要更底层的理解接口值的相关内容参考：</p>
<p><a href="https://lianglianglee.com/%E4%B8%93%E6%A0%8F/Tony%20Bai%20%C2%B7%20Go%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%80%E8%AF%BE/29%20%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88nil%E6%8E%A5%E5%8F%A3%E4%B8%8D%E7%AD%89%E4%BA%8Enil%EF%BC%9F.md">《GO语言第一课 29接口：为什么nil不等于nil》</a></p>
<h2 id="类型断言">类型断言</h2>
<p>接口值可能赋值为任意类型的值，那我们如何从接口值获取其存储的具体数据呢？</p>
<p>我们可以借助标准库<code>fmt</code>包的格式化打印获取到接口值的动态类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">m</span> <span class="nx">Mover</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">m</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Dog</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;旺财&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="c1">// *main.Dog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">m</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Car</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="c1">// *main.Car
</span></span></span></code></pre></div><p>而<code>fmt</code>包内部其实是使用反射的机制在程序运行时获取到动态类型的名称。</p>
<p>而想要从接口值中获取到对应的实际值需要使用类型断言，其语法格式如下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">x</span><span class="p">.(</span><span class="nx">T</span><span class="p">)</span>
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>x：表示接口类型的变量</li>
<li>T：表示断言<code>x</code>可能是的类型。</li>
</ul>
<p>该语法返回两个参数，第一个参数是<code>x</code>转化为<code>T</code>类型后的变量，第二个值是一个布尔值，若为<code>true</code>则表示断言成功，为<code>false</code>则表示断言失败。</p>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">n</span> <span class="nx">Mover</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Dog</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;旺财&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.(</span><span class="o">*</span><span class="nx">Dog</span><span class="p">)</span>	<span class="c1">// n.(*Dog) =&gt; X.(T)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;类型断言成功&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">v</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">&#34;富贵&#34;</span> <span class="c1">// 变量v是*Dog类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;类型断言失败&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>如果对一个接口值有多个实际类型需要判断，推荐使用<code>switch</code>语句来实现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// justifyType 对传入的空接口类型变量x进行类型断言
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">justifyType</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x is a string，value is %v\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x is a int is %v\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="kt">bool</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x is a bool is %v\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;unsupport type！&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>由于接口类型变量能够动态存储不同类型值的特点，所以很多初学者会滥用接口类型（特别是空接口）来实现编码过程中的便捷。只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。切记不要为了使用接口类型而增加不必要的抽象，导致不必要的运行时损耗。</p>
<p>在 Go 语言中接口是一个非常重要的概念和特性，使用接口类型能够实现代码的抽象和解耦，也可以隐藏某个功能的内部实现，但是缺点就是在查看源码的时候，不太方便查找到具体实现接口的类型。</p>
<p>相信很多读者在刚接触到接口类型时都会有很多疑惑，请牢记接口是一种类型，一种抽象的类型。区别于我们在之前章节提到的那些具体类型（整型、数组、结构体类型等），它是一个只要求实现特定方法的抽象类型。</p>
<p><strong>小技巧：</strong> 下面的代码可以在程序编译阶段验证某一结构体是否满足特定的接口类型。</p>
<pre tabindex="0"><code>// 摘自gin框架routergroup.go
type IRouter interface{ ... }

type RouterGroup struct { ... }

var _ IRouter = &amp;RouterGroup{}  // 声明一个接口变量类型 IRouter，变量名我们不关系，直接用 _ 作为占位符。 将 &amp;RouterGroup{}（类型是 *RouterGroup）赋值给一个接口类型变量 IRouter。如果 *RouterGroup 没有实现 IRouter 中的所有方法，就会在编译时报错！
</code></pre><p>当然，实际上更喜欢用如下进行验证</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">_</span> <span class="nx">IRouter</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">RouterGroup</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>	<span class="c1">//(*RouterGroup)(nil)等价于var p *RouterGroup = nil，即：创建一个类型为 *RouterGroup 的 nil 值，也就是一个类型为 *RouterGroup 的 “空指针”
</span></span></span></code></pre></div><h2 id="接口练习题">接口练习题</h2>
<p>要求：使用接口的方式实现一个既可以往终端写日志也可以往文件写日志的简易日志库。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//qyyLog包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">qyyLog</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;io&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">PrintLoger</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintLog</span><span class="p">(</span><span class="nx">logString</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义向终端打印日志的接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Terminal</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义往日志写文件的接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">File</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义需要写入的文件名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">LogFileName</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 终端实现这个打印日志接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Terminal</span><span class="p">)</span> <span class="nf">PrintLog</span><span class="p">(</span><span class="nx">logString</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">logString</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 文件实现这个打印日志接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">File</span><span class="p">)</span> <span class="nf">PrintLog</span><span class="p">(</span><span class="nx">logString</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义文件类型变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">file</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 先判断这个文件是否存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nf">CheckFileIsExist</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">LogFileName</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 文件存在时，打开文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">file</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">LogFileName</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_APPEND</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">,</span> <span class="mo">0666</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 文件不存在是，创建文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">file</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">LogFileName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 最后关闭文件（文件有打开就有关闭）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 开始写入数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="nx">logString</span><span class="o">+</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;写入 %d 个字节\n&#34;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 判断文件是否存在的方法（看评论区大神的）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">CheckFileIsExist</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Stat</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">//main
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//定义终端结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">terminal</span> <span class="o">:=</span> <span class="nx">qyyLog</span><span class="p">.</span><span class="nx">Terminal</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义文件结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">file</span> <span class="o">:=</span> <span class="nx">qyyLog</span><span class="p">.</span><span class="nx">File</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">LogFileName</span><span class="p">:</span> <span class="s">&#34;log.txt&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">printer</span> <span class="nx">qyyLog</span><span class="p">.</span><span class="nx">PrintLoger</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 终端打印日志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">printer</span><span class="p">=</span><span class="nx">terminal</span>
</span></span><span class="line"><span class="cl">	<span class="nx">printer</span><span class="p">.</span><span class="nf">PrintLog</span><span class="p">(</span><span class="s">&#34;永无bug！&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 文件打印日志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">printer</span><span class="p">=</span><span class="o">&amp;</span><span class="nx">file</span>
</span></span><span class="line"><span class="cl">	<span class="nx">printer</span><span class="p">.</span><span class="nf">PrintLog</span><span class="p">(</span><span class="s">&#34;永无bug！&#34;</span><span class="p">)</span>
</span></span></code></pre></div><h1 id="反射">反射</h1>
<h2 id="变量的内在机制">变量的内在机制</h2>
<p>Go语言中的变量是分为两部分的：</p>
<ul>
<li>类型信息：预先定义好的元信息。</li>
<li>值信息：程序运行过程中可动态变化的。</li>
</ul>
<h2 id="反射的介绍">反射的介绍</h2>
<p>反射是指在程序运行期间对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p>
<p>支持反射的语言可以在程序编译期间将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期间获取类型的反射信息，并且有能力修改它们。</p>
<p>Go程序在运行期间使用reflect包访问程序的反射信息。</p>
<p>前面我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。</p>
<h2 id="reflect包">reflect包</h2>
<p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的。（前面的接口值中我们介绍过相关概念）</p>
<p>在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p>
<h3 id="typeof">TypeOf</h3>
<p>在Go语言中，使用<code>reflect.TypeOf()</code>函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;reflect&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">reflectType</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type:%v\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">a</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">3.14</span>
</span></span><span class="line"><span class="cl">	<span class="nf">reflectType</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// type:float32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">b</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="nf">reflectType</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// type:int64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>type name 和 type kind</strong></p>
</blockquote>
<p>在反射中关于类型还划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<code>种类（Kind）</code>就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到<code>种类（Kind）</code>。</p>
<p>举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;reflect&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">myInt</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">reflectType</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type:%v kind:%v\n&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">float32</span> <span class="c1">// 指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">b</span> <span class="nx">myInt</span>    <span class="c1">// 自定义类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">c</span> <span class="kt">rune</span>     <span class="c1">// 类型别名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">reflectType</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// type: kind:ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">reflectType</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// type:myInt kind:int64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">reflectType</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// type:int32 kind:int32
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">		<span class="nx">age</span>  <span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">type</span> <span class="nx">book</span> <span class="kd">struct</span><span class="p">{</span> <span class="nx">title</span> <span class="kt">string</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">d</span> <span class="p">=</span> <span class="nx">person</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">name</span><span class="p">:</span> <span class="s">&#34;沙河小王子&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">age</span><span class="p">:</span>  <span class="mi">18</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">e</span> <span class="p">=</span> <span class="nx">book</span><span class="p">{</span><span class="nx">title</span><span class="p">:</span> <span class="s">&#34;《跟小王子学Go语言》&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">reflectType</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="c1">// type:person kind:struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">reflectType</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="c1">// type:book kind:struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的<code>.Name()</code>都是返回<code>空</code>。</p>
<p>在<code>reflect</code>包中定义的Kind类型如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Kind</span> <span class="kt">uint</span>
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Invalid</span> <span class="nx">Kind</span> <span class="p">=</span> <span class="kc">iota</span>  <span class="c1">// 非法类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Bool</span>                 <span class="c1">// 布尔型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Int</span>                  <span class="c1">// 有符号整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Int8</span>                 <span class="c1">// 有符号8位整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Int16</span>                <span class="c1">// 有符号16位整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Int32</span>                <span class="c1">// 有符号32位整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Int64</span>                <span class="c1">// 有符号64位整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Uint</span>                 <span class="c1">// 无符号整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Uint8</span>                <span class="c1">// 无符号8位整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Uint16</span>               <span class="c1">// 无符号16位整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Uint32</span>               <span class="c1">// 无符号32位整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Uint64</span>               <span class="c1">// 无符号64位整型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Uintptr</span>              <span class="c1">// 指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Float32</span>              <span class="c1">// 单精度浮点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Float64</span>              <span class="c1">// 双精度浮点数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Complex64</span>            <span class="c1">// 64位复数类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Complex128</span>           <span class="c1">// 128位复数类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Array</span>                <span class="c1">// 数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Chan</span>                 <span class="c1">// 通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Func</span>                 <span class="c1">// 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Interface</span>            <span class="c1">// 接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Map</span>                  <span class="c1">// 映射
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Ptr</span>                  <span class="c1">// 指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Slice</span>                <span class="c1">// 切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">String</span>               <span class="c1">// 字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Struct</span>               <span class="c1">// 结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">UnsafePointer</span>        <span class="c1">// 底层指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></div><h3 id="valueof">ValueOf</h3>
<p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p>
<p><code>reflect.Value</code>类型提供的获取原始值的方法如下：</p>
<p><img 
  src="./2025-0331-01/image-20250622111747184.png" 
  alt="image-20250622111747184" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250622111747184.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<blockquote>
<p><strong>通过反射获取值</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">reflectValue</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">k</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">k</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int64</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type is int64, value is %d\n&#34;</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Int</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Float32</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type is float32, value is %f\n&#34;</span><span class="p">,</span> <span class="nb">float32</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Float</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Float64</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type is float64, value is %f\n&#34;</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Float</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">a</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">3.14</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">b</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="nf">reflectValue</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// type is float32, value is 3.140000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">reflectValue</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// type is int64, value is 100
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 将int类型的原始值转换为reflect.Value类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;type c :%T\n&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="c1">// type c :reflect.Value，  reflect.ValueOf() 返回的是 reflect.Value 类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p><strong>通过反射设置变量的值</strong></p>
</blockquote>
<p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;reflect&#34;
)

func reflectSetValue1(x interface{}) {
	v := reflect.ValueOf(x)
	if v.Kind() == reflect.Int64 {
		v.SetInt(200) //修改的是副本，reflect包会引发panic
	}
}
func reflectSetValue2(x interface{}) {
	v := reflect.ValueOf(x)
	// 反射中使用 Elem()方法获取指针对应的值
	if v.Elem().Kind() == reflect.Int64 {
		v.Elem().SetInt(200)
	}
}
func main() {
	var a int64 = 100
	// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value
	reflectSetValue2(&amp;a)
	fmt.Println(a)
}
</code></pre><p><img 
  src="./2025-0331-01/image-20250622121229700.png" 
  alt="image-20250622121229700" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250622121229700.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<blockquote>
<p><strong>isNil() 和 isValid()</strong></p>
</blockquote>
<p><strong>isNil()</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">IsNil</span><span class="p">()</span> <span class="kt">bool</span>
</span></span></code></pre></div><p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p>
<p><strong>isValid()</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Value</span><span class="p">)</span> <span class="nf">IsValid</span><span class="p">()</span> <span class="kt">bool</span>
</span></span></code></pre></div><p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p>
<p>举个例子：<code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// *int类型空指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;var a *int IsNil:&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nf">IsNil</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// nil值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;nil IsValid:&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="kc">nil</span><span class="p">).</span><span class="nf">IsValid</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 实例化一个匿名结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="kd">struct</span><span class="p">{}{}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 尝试从结构体中查找&#34;abc&#34;字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;不存在的结构体成员:&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">b</span><span class="p">).</span><span class="nf">FieldByName</span><span class="p">(</span><span class="s">&#34;abc&#34;</span><span class="p">).</span><span class="nf">IsValid</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 尝试从结构体中查找&#34;abc&#34;方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;不存在的结构体方法:&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">b</span><span class="p">).</span><span class="nf">MethodByName</span><span class="p">(</span><span class="s">&#34;abc&#34;</span><span class="p">).</span><span class="nf">IsValid</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 尝试从map中查找一个不存在的键
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;map中不存在的键：&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">c</span><span class="p">).</span><span class="nf">MapIndex</span><span class="p">(</span><span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="s">&#34;娜扎&#34;</span><span class="p">)).</span><span class="nf">IsValid</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250622150219202.png" 
  alt="image-20250622150219202" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250622150219202.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h2 id="结构体反射">结构体反射</h2>
<h3 id="与结构体相关的方法">与结构体相关的方法</h3>
<p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（<code>reflect.Type</code>）的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p>
<p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示。</p>
<p><img 
  src="./2025-0331-01/image-20250622150645371.png" 
  alt="image-20250622150645371" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250622150645371.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h3 id="structfield类型">StructField类型</h3>
<p><code>StructField</code>类型用来描述结构体中的一个字段的信息。</p>
<p><code>StructField</code>的定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StructField</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&#34;&#34;。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Name</span>    <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">PkgPath</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Type</span>      <span class="nx">Type</span>      <span class="c1">// 字段的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Tag</span>       <span class="nx">StructTag</span> <span class="c1">// 字段的标签
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Offset</span>    <span class="kt">uintptr</span>   <span class="c1">// 字段在结构体中的字节偏移量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Index</span>     <span class="p">[]</span><span class="kt">int</span>     <span class="c1">// 用于Type.FieldByIndex时的索引切片
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Anonymous</span> <span class="kt">bool</span>      <span class="c1">// 是否匿名字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h3 id="结构体反射示例">结构体反射示例</h3>
<p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">student</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Score</span> <span class="kt">int</span>    <span class="s">`json:&#34;score&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">stu1</span> <span class="o">:=</span> <span class="nx">student</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Name</span><span class="p">:</span>  <span class="s">&#34;小王子&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Score</span><span class="p">:</span> <span class="mi">90</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">stu1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span> <span class="c1">// student struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 通过for循环遍历结构体的所有字段信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">t</span><span class="p">.</span><span class="nf">NumField</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">field</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;name:%s index:%d type:%v json tag:%v\n&#34;</span><span class="p">,</span> <span class="nx">field</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">field</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">field</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">field</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;json&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 通过字段名获取指定结构体字段信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">scoreField</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">FieldByName</span><span class="p">(</span><span class="s">&#34;Score&#34;</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;name:%s index:%d type:%v json tag:%v\n&#34;</span><span class="p">,</span> <span class="nx">scoreField</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">scoreField</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">scoreField</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">scoreField</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;json&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250622151615597.png" 
  alt="image-20250622151615597" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250622151615597.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>接下来编写一个函数<code>printMethod(s interface{})</code>来遍历打印s包含的方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">// 给student添加两个方法 Study和Sleep(注意首字母大写)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">student</span><span class="p">)</span> <span class="nf">Study</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">msg</span> <span class="o">:=</span> <span class="s">&#34;好好学习，天天向上。&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">msg</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">student</span><span class="p">)</span> <span class="nf">Sleep</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">msg</span> <span class="o">:=</span> <span class="s">&#34;好好睡觉，快快长大。&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">msg</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">printMethod</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nf">NumMethod</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nf">NumMethod</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">methodType</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Method</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nf">Type</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;method name:%s\n&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Method</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nx">Name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;method:%s\n&#34;</span><span class="p">,</span> <span class="nx">methodType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kd">var</span> <span class="nx">args</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">v</span><span class="p">.</span><span class="nf">Method</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nf">Call</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="反射练习题">反射练习题</h2>
<p>编写代码利用反射实现一个ini文件的解析器程序。</p>
<p>因为什么需要 ini 文件？方便管理各种项目的配置文件，如：mysql、redis等配置</p>
<p>project.ini 文件如下：</p>
<pre tabindex="0"><code>** 关于 mysql 的配置块
[mysql]
## 数据库的连接地址
db=jdbc:mysql://127.0.0.1:3306/test_db
// 数据库的登录账户
username=mysql_username
# 数据库的登录密码
password=mysql_password

** 关于 redis 的配置块
[redis]
ip=127.0.0.1
port=1234
username=redis_username
password=redis_password
</code></pre><p>实现代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;errors&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;io/ioutil&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;os&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;reflect&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strconv&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strings&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 1. 将 ini 读取到内存
</span></span></span><span class="line"><span class="cl"><span class="c1">// 2. 解析 ini 文件内容，将 k-v 存储到 map 中
</span></span></span><span class="line"><span class="cl"><span class="c1">// 3. 使用反射和 json tag，给结构体赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MysqlConfig</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">DB</span>       <span class="kt">string</span> <span class="s">`ini:&#34;db&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Username</span> <span class="kt">string</span> <span class="s">`ini:&#34;username&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Password</span> <span class="kt">string</span> <span class="s">`ini:&#34;password&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">RedisConfig</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">IP</span>       <span class="kt">string</span> <span class="s">`ini:&#34;ip&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Port</span>     <span class="kt">int</span>    <span class="s">`ini:&#34;port&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Username</span> <span class="kt">string</span> <span class="s">`ini:&#34;username&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Password</span> <span class="kt">string</span> <span class="s">`ini:&#34;password&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MysqlConfig</span> <span class="s">`ini:&#34;mysql&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">RedisConfig</span> <span class="s">`ini:&#34;redis&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 解析文件内容，得到 map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">parseFile</span><span class="p">(</span><span class="nx">filePath</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nf">Executable</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 读取文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fileContent</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">filePath</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rows</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">fileContent</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span> <span class="c1">// 换行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">currentKey</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rows</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">row</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nf">IsIgnore</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 获取 [xxx] 中的 xxx 字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="s">&#34;[&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasSuffix</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="s">&#34;]&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">row</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">ReplaceAll</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="s">&#34;[&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">row</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">ReplaceAll</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="s">&#34;]&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">currentKey</span> <span class="p">=</span> <span class="nx">row</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 已有
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">row</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">m</span><span class="p">[</span><span class="nx">row</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 还没找到 [xxx]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">currentKey</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 找到第一个 =
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">idx</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Index</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="s">&#34;=&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">key</span> <span class="o">:=</span> <span class="nx">row</span><span class="p">[:</span><span class="nx">idx</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="nx">value</span> <span class="o">:=</span> <span class="nx">row</span><span class="p">[</span><span class="nx">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">		<span class="nx">m</span><span class="p">[</span><span class="nx">currentKey</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// IsIgnore 是否忽略
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">IsIgnore</span><span class="p">(</span><span class="nx">line</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">line</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 忽略注释行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;**&#34;</span><span class="p">,</span> <span class="s">&#34;//&#34;</span><span class="p">,</span> <span class="s">&#34;#&#34;</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// LoadConfig 将 m 中的数据反射进 dataType 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">LoadConfig</span><span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">dataType</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// reflect.Type 类型遍历结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// reflect.Value 类型为结构体赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">dataType</span><span class="p">).</span><span class="nf">Elem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">dataType</span><span class="p">).</span><span class="nf">Elem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 遍历结构体第一层，MysqlConfig 和 RedisConfig
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">t</span><span class="p">.</span><span class="nf">NumField</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">field</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Field</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tagValue</span> <span class="o">:=</span> <span class="nx">field</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;ini&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tagValue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 找到对应的内部 map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">itemMap</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">tagValue</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 找到上层结构体的 reflect.Value，方便等下赋值使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">structValue</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">FieldByName</span><span class="p">(</span><span class="nx">field</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 找到上层结构体的 reflect.Type，方便对内层结构体字段进行遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">structType</span> <span class="o">:=</span> <span class="nx">structValue</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 针对结构体的每个字段进行赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">structType</span><span class="p">.</span><span class="nf">NumField</span><span class="p">();</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">structField</span> <span class="o">:=</span> <span class="nx">structType</span><span class="p">.</span><span class="nf">Field</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">structTagValue</span> <span class="o">:=</span> <span class="nx">structField</span><span class="p">.</span><span class="nx">Tag</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;ini&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">structTagValue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// 找到对应的 map 中的 value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">itemValue</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">itemMap</span><span class="p">[</span><span class="nx">structTagValue</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// 进行赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">fieldValue</span> <span class="o">:=</span> <span class="nx">structValue</span><span class="p">.</span><span class="nf">FieldByName</span><span class="p">(</span><span class="nx">structField</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">err</span> <span class="o">:=</span> <span class="nf">setValue</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fieldValue</span><span class="p">,</span> <span class="nx">itemValue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;[warn]字段[%s]无法进行赋值,error: %v\n&#34;</span><span class="p">,</span> <span class="nx">structField</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 利用反射，进行赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">setValue</span><span class="p">(</span><span class="nx">fieldObj</span> <span class="o">*</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">str</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">fieldObj</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">String</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fieldObj</span><span class="p">.</span><span class="nf">SetString</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">atoi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fieldObj</span><span class="p">.</span><span class="nf">SetInt</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">atoi</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;缺少类型转换,请添加[ &#34;</span> <span class="o">+</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">fieldObj</span><span class="p">.</span><span class="nf">Kind</span><span class="p">())</span> <span class="o">+</span> <span class="s">&#34; ]转换类型&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// checkDataType 检查 dataType
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">checkDataType</span><span class="p">(</span><span class="nx">dataType</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">dataType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Ptr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;请传入一个指针的类型变量&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">dataType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Elem</span><span class="p">().</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;请传入一个指针的类型结构体变量&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// LoadConfigFile 根据配置文件设置 config
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">LoadConfigFile</span><span class="p">(</span><span class="nx">filePath</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">dataType</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 检查 dataType
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">err</span> <span class="o">:=</span> <span class="nf">checkDataType</span><span class="p">(</span><span class="nx">dataType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;出错了,&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 解析文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">configMap</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">parseFile</span><span class="p">(</span><span class="nx">filePath</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;出错了,&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;解析到 map 为：%+v&#34;</span><span class="p">,</span> <span class="nx">configMap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 写入 dataType
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nf">LoadConfig</span><span class="p">(</span><span class="nx">configMap</span><span class="p">,</span> <span class="nx">dataType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;出错了,&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">c</span> <span class="nx">Config</span>
</span></span><span class="line"><span class="cl">	<span class="nf">LoadConfigFile</span><span class="p">(</span><span class="s">&#34;./practice/project.ini&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="并发">并发</h1>
<h2 id="基本概念">基本概念</h2>
<h3 id="串行并发与并行">串行、并发与并行</h3>
<p>串行：我们都是先读小学，小学毕业后再读初中，读完初中再读高中。</p>
<p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p>
<p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p>
<h3 id="进程线程和协程">进程、线程和协程</h3>
<p>进程（process）：程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。</p>
<p>线程（thread）：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位。</p>
<p>协程（coroutine）：非操作系统提供而是由用户自行创建和控制的用户态‘线程’，比线程更轻量级。</p>
<h3 id="并发模型">并发模型</h3>
<p>业界将如何实现并发编程总结归纳为各式各样的并发模型，常见的并发模型有以下几种：</p>
<ul>
<li>线程&amp;锁模型</li>
<li>Actor模型</li>
<li>CSP模型</li>
<li>Fork&amp;Join模型</li>
</ul>
<p>Go语言中的并发程序主要是通过基于CSP（communicating sequential processes）的goroutine和channel来实现，当然也支持使用传统的多线程共享内存的并发方式。</p>
<h2 id="goroutine">goroutine</h2>
<p>Goroutine 是 Go 语言支持并发的核心，在一个Go程序中同时创建成百上千个goroutine是非常普遍的，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。区别于操作系统线程由系统内核进行调度， goroutine 是由Go运行时（runtime）负责调度。例如Go运行时会智能地将 m个goroutine 合理地分配给n个操作系统线程，实现类似m:n的调度机制，不再需要Go开发者自行在代码层面维护一个线程池。</p>
<p>Goroutine 是 Go 程序中最基本的并发执行单元。每一个 Go 程序都至少包含一个 goroutine——main goroutine，当 Go 程序启动时它会自动创建。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能——goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个 goroutine 去执行这个函数就可以了，就是这么简单粗暴。</p>
<h3 id="go-关键字">go 关键字</h3>
<p>Go语言中使用 goroutine 非常简单，只需要在函数或方法调用前加上<code>go</code>关键字就可以创建一个 goroutine ，从而让该函数或方法在新创建的 goroutine 中执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">go</span> <span class="nf">f</span><span class="p">()</span>  <span class="c1">// 创建一个新的 goroutine 运行函数f
</span></span></span></code></pre></div><p>匿名函数也支持使用<code>go</code>关键字创建 goroutine 去执行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}()</span>
</span></span></code></pre></div><p>一个 goroutine 必定对应一个函数/方法，可以创建多个 goroutine 去执行相同的函数/方法。</p>
<h3 id="启动单个-goroutine">启动单个 goroutine</h3>
<p>启动 goroutine 的方式非常简单，只需要在调用函数（普通函数和匿名函数）前加上一个<code>go</code>关键字。</p>
<p>我们先来看一个在 main 函数中执行普通函数调用的示例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">hello</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;你好&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250622163116089.png" 
  alt="image-20250622163116089" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250622163116089.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>代码中 hello 函数和其后面的打印语句是串行的。</p>
<p><img 
  src="./2025-0331-01/image-20250622163200966.png" 
  alt="image-20250622163200966" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250622163200966.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>接下来我们在调用 hello 函数前面加上关键字<code>go</code>，也就是启动一个 goroutine 去执行 hello 这个函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">hello</span><span class="p">()</span> <span class="c1">// 启动另外一个goroutine去执行hello函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;你好&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>将上述代码重新编译后执行，得到输出结果如下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">你好
</span></span></code></pre></div><p>这一次的执行结果只在终端打印了&quot;你好&quot;，并没有打印 <code>hello</code>。这是为什么呢？</p>
<p>其实在 Go 程序启动时，Go 程序就会为 main 函数创建一个默认的 goroutine 。在上面的代码中我们在 main 函数中使用 go 关键字创建了另外一个 goroutine 去执行 hello 函数，而此时 main goroutine 还在继续往下执行，我们的程序中此时存在两个并发执行的 goroutine。当 main 函数结束时整个程序也就结束了，同时 main goroutine 也结束了，所有由 main goroutine 创建的 goroutine 也会一同退出。也就是说我们的 main 函数退出太快，另外一个 goroutine 中的函数还未执行完程序就退出了，导致未打印出“hello”。</p>
<p>所以我们要想办法让 main 函数“等一等”将在另一个 <code>goroutine</code> 中运行的 <code>hello</code> 函数。其中最简单粗暴的方式就是在 main 函数中“time.Sleep”1秒钟了（这里的1秒钟是我们根据经验而设置的一个值，在这个示例中1秒钟足够创建新的<code>goroutine</code>执行完<code>hello</code>函数了）。</p>
<p>按如下方式修改我们的示例代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">hello</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;你好&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>将我们的程序重新编译后再次执行，程序会在终端输出如下结果，并且会<strong>短暂停顿</strong>一会儿。</p>
<pre tabindex="0"><code>你好
hello
</code></pre><p>运行了多次后，我们发现每次都是先打印<code>你好</code>，为什么呢？</p>
<p>这是因为在程序中创建 goroutine 执行函数需要一定的开销，而与此同时 main 函数所在的 goroutine 是继续执行的。</p>
<p><img 
  src="./2025-0331-01/image-20250622164359931.png" 
  alt="image-20250622164359931" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250622164359931.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>在上面的程序中使用<code>time.Sleep</code>让 main goroutine 等待 hello goroutine执行结束是不优雅的，当然也是不准确的。</p>
<p>Go 语言中通过<code>sync</code>包为我们提供了一些常用的并发原语，我们会在后面的小节单独介绍<code>sync</code>包中的内容。</p>
<p>在这一小节，我们会先介绍一下 sync 包中的<code>WaitGroup</code>。当你并不关心并发操作的结果或者有其它方式收集并发操作的结果时，<code>WaitGroup</code>是实现等待一组并发操作完成的好方法。</p>
<p>下面的示例代码中我们在 main goroutine 中使用<code>sync.WaitGroup</code>来等待 hello goroutine 完成后再退出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 声明全局等待组变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span> <span class="c1">// 告知当前goroutine完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 登记1个goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="nf">hello</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;你好&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span> <span class="c1">// 阻塞等待登记的goroutine完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>将代码编译后再执行，得到的输出结果和之前一致，但是这一次程序不再会有多余的停顿，hello goroutine 执行完毕后程序直接退出。</p>
<blockquote>
<p><strong>补充：由于后面的例子中会频繁出现 wg.wait 的一些用法，所以在这里提前了解</strong></p>
</blockquote>
<p><code>wg.Add()</code>、<code>wg.Done()</code>、<code>wg.Wait()</code> 是  <code>sync.WaitGroup</code>  的三大核心用法，WaitGroup 就像一个任务计数器：</p>
<ul>
<li>一共多少任务（Add(n)）</li>
<li>每个任务干完之后告诉我（Done()）</li>
<li>等待所有任务完成后再继续后续操作（Wait(n)）</li>
</ul>
<p>举个例子：</p>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;sync&#34;
	&#34;time&#34;
)

func main() {
	var wg sync.WaitGroup

	wg.Add(3) // 启动 3 个任务

	go func() {
		defer wg.Done() // 任务完成
		time.Sleep(1 * time.Second)
		fmt.Println(&#34;任务 1 完成&#34;)
	}()

	go func() {
		defer wg.Done()
		time.Sleep(2 * time.Second)
		fmt.Println(&#34;任务 2 完成&#34;)
	}()

	go func() {
		defer wg.Done()
		time.Sleep(3 * time.Second)
		fmt.Println(&#34;任务 3 完成&#34;)
	}()

	wg.Wait() // 等待所有任务完成
	fmt.Println(&#34;所有任务完成，程序结束&#34;)
}
</code></pre><p><img 
  src="./2025-0331-01/image-20250630214705626.png" 
  alt="image-20250630214705626" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250630214705626.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p><img 
  src="./2025-0331-01/image-20250630214756942.png" 
  alt="image-20250630214756942" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250630214756942.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h3 id="启动多个-goroutine">启动多个 goroutine</h3>
<p>在 Go 语言中实现并发就是这样简单，我们还可以启动多个 goroutine 。让我们再来看一个新的代码示例。这里同样使用了<code>sync.WaitGroup</code>来实现 goroutine 的同步。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">hello</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span> <span class="c1">// goroutine结束就登记-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 启动一个goroutine就登记+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">go</span> <span class="nf">hello</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span> <span class="c1">// 等待所有登记的goroutine都结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>多次执行上面的代码会发现每次终端上打印数字的顺序都不一致。这是因为10个 goroutine 是并发执行的，而 goroutine 的调度是随机的。</p>
<h3 id="动态栈">动态栈</h3>
<p>操作系统的线程一般都有固定的栈内存（通常为2MB）,而 Go 语言中的 goroutine 非常轻量级，一个 goroutine 的初始栈空间很小（一般为2KB），所以在 Go 语言中一次创建数万个 goroutine 也是可能的。并且 goroutine 的栈不是固定的，可以根据需要动态地增大或缩小， Go 的 runtime 会自动为 goroutine 分配合适的栈空间。</p>
<h3 id="goroutine-调度">goroutine 调度</h3>
<p>操作系统内核在调度时会挂起当前正在执行的线程并将寄存器中的内容保存到内存中，然后选出接下来要执行的线程并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。从一个线程切换到另一个线程需要完整的上下文切换。因为可能需要多次内存访问，索引这个切换上下文的操作开销较大，会增加运行的cpu周期。</p>
<p>区别于操作系统内核调度操作系统线程，goroutine 的调度是Go语言运行时（runtime）层面的实现，是完全由 Go 语言本身实现的一套调度系统——go scheduler。它的作用是按照一定的规则将所有的 goroutine 调度到操作系统线程上执行。</p>
<p>在经历数个版本的迭代之后，目前 Go 语言的调度器采用的是 <code>GPM</code> 调度模型。</p>
<p><img 
  src="./2025-0331-01/image-20250622165400671.png" 
  alt="image-20250622165400671" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250622165400671.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>其中：</p>
<ul>
<li>G：表示 goroutine，每执行一次<code>go f()</code>就创建一个 G，包含要执行的函数和上下文信息。</li>
<li>全局队列（Global Queue）：存放等待运行的 G。</li>
<li>P：表示 goroutine 执行所需的资源，最多有 GOMAXPROCS 个。</li>
<li>P 的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果本地队列满了会批量移动部分 G 到全局队列。</li>
<li>M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li>
<li>Goroutine 调度器和操作系统调度器是通过 M 结合起来的，每个 M 都代表了1个内核线程，操作系统调度器负责把内核线程分配到 CPU 的核上执行。</li>
</ul>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。</p>
<h3 id="gomaxprocs">GOMAXPROCS</h3>
<p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过<code>runtime.GOMAXPROCS</code>函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的CPU 逻辑核心数。）</p>
<h2 id="channel">channel</h2>
<p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p>
<p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的 goroutine 中容易发生竞态问题。为了保证数据交换的正确性，很多并发模型中必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p>
<p>Go语言采用的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p>
<p>如果说 goroutine 是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。</p>
<p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p>
<h3 id="channel-类型">channel 类型</h3>
<p><code>channel</code>是 Go 语言中一种特有的类型。声明通道类型变量的格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">变量名称</span> <span class="kd">chan</span> <span class="nx">元素类型</span>
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>chan：是关键字</li>
<li>元素类型：是指通道中传递元素的类型</li>
</ul>
<p>举几个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ch1</span> <span class="kd">chan</span> <span class="kt">int</span>   <span class="c1">// 声明一个传递整型的通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ch2</span> <span class="kd">chan</span> <span class="kt">bool</span>  <span class="c1">// 声明一个传递布尔型的通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">ch3</span> <span class="kd">chan</span> <span class="p">[]</span><span class="kt">int</span> <span class="c1">// 声明一个传递int切片的通道
</span></span></span></code></pre></div><h3 id="channel-零值">channel 零值</h3>
<p>未初始化的通道类型变量其默认零值是<code>nil</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// &lt;nil&gt;
</span></span></span></code></pre></div><h3 id="初始化-channel">初始化 channel</h3>
<p>声明的通道类型变量需要使用内置的<code>make</code>函数初始化之后才能使用。具体格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">元素类型</span><span class="p">,</span> <span class="p">[</span><span class="nx">缓冲大小</span><span class="p">])</span>
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>channel的缓冲大小是可选的。</li>
</ul>
<p>举几个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">ch4</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">ch5</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">// 声明一个缓冲区大小为1的通道
</span></span></span></code></pre></div><h3 id="channel-操作">channel 操作</h3>
<p>通道共有发送（send）、接收(receive）和关闭（close）三种操作。而发送和接收操作都使用<code>&lt;-</code>符号。</p>
<p>现在我们先使用以下语句定义一个通道：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span></code></pre></div><blockquote>
<p><strong>发送</strong></p>
</blockquote>
<p>将一个值发送到通道中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">10</span> <span class="c1">// 把10发送到ch中
</span></span></span></code></pre></div><blockquote>
<p><strong>接收</strong></p>
</blockquote>
<p>从一个通道中接收值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">ch</span> <span class="c1">// 从ch中接收值并赋值给变量x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&lt;-</span><span class="nx">ch</span>       <span class="c1">// 从ch中接收值，忽略结果
</span></span></span></code></pre></div><blockquote>
<p><strong>关闭</strong></p>
</blockquote>
<p>我们通过调用内置的<code>close</code>函数来关闭通道。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span></code></pre></div><p><strong>注意</strong>：一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<p>关闭后的通道有以下特点：</p>
<ul>
<li>对一个关闭的通道再发送值就会导致 panic。</li>
<li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li>
<li>关闭一个已经关闭的通道会导致 panic。</li>
</ul>
<p>我们是可以从关闭的通道中读取已有数据的，关闭通道后，相当于只能读不能写。</p>
<h3 id="无缓冲的通道同步通道">无缓冲的通道（同步通道）</h3>
<p>无缓冲的通道又称为阻塞的通道。我们来看一下如下代码片段。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;发送成功&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">fatal error: all goroutines are asleep - deadlock!
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">goroutine <span class="m">1</span> <span class="o">[</span>chan send<span class="o">]</span>:
</span></span><span class="line"><span class="cl">main.main<span class="o">()</span>
</span></span><span class="line"><span class="cl">        .../main.go:8 +0x54
</span></span></code></pre></div><p><code>deadlock</code>表示我们程序中的 goroutine 都被挂起导致程序死锁了。为什么会出现<code>deadlock</code>错误呢？</p>
<p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有接收方能够接收值的时候才能发送成功，否则会一直处于等待发送的阶段。同理，如果对一个无缓冲通道执行接收操作时，没有任何向通道中发送值的操作那么也会导致接收操作阻塞。就像田径比赛中的4x100接力赛，想要完成交棒必须有一个能够接棒的运动员，否则只能等待。简单来说就是无缓冲的通道必须有至少一个接收方才能发送成功。</p>
<p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p>
<p>其中一种可行的方法是创建一个 goroutine 去接收值，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">recv</span><span class="p">(</span><span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ret</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;接收成功&#34;</span><span class="p">,</span> <span class="nx">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">recv</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// 创建一个 goroutine 从通道接收值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;发送成功&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>首先无缓冲通道<code>ch</code>上的发送操作<code>会阻塞</code>，直到另一个 goroutine 在该通道上执行接收操作，这时数字10才能发送成功，两个 goroutine 将继续执行。相反，如果接收操作先执行，接收方所在的 goroutine 将阻塞，直到 main goroutine 中向该通道发送数字10。</p>
<p>使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p>
<h3 id="有缓冲的通道">有缓冲的通道</h3>
<p>还有另外一种解决上面死锁问题的方法，那就是使用有缓冲区的通道。我们可以在使用 make 函数初始化通道时，可以为其指定通道的容量，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 创建一个容量为1的有缓冲区通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;发送成功&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>只要通道的容量大于零，那么该通道就属于有缓冲的通道，通道的容量表示通道中最大能存放的元素数量。当通道内已有元素数达到最大容量后，再向通道执行发送操作就会阻塞，除非有从通道执行接收操作。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>
<p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p>
<h3 id="多返回值模式">多返回值模式</h3>
<p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。当一个通道被关闭后，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值。通道内的值被接收完后再对通道执行接收操作得到的值会一直都是对应元素类型的零值。那我们如何判断一个通道是否被关闭了呢 ？</p>
<p><strong>注意</strong>：上面我们提到了使用 close(ch) 关闭通道，是的，close(ch) 确实关闭了通道，但是这是作为发送方关闭的通道，但此时这里是接收方，接收方并不知道通道有没有关闭，所以接收方需要判断通道是否关闭。</p>
<p>具体判断方法如下：</p>
<p>对一个通道执行接收操作时支持使用如下多返回值模式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">ch</span>
</span></span></code></pre></div><p>其中：</p>
<ul>
<li>value：从通道中取出的值，如果通道对应类型的零值。</li>
<li>ok：通道 <code>ch 关闭</code> 时返回 false，否则返回 true。</li>
</ul>
<p>下面代码片段中的<code>f2</code>函数会循环从通道<code>ch</code>中接收所有值，直到取完通道内所有的值后退出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">f2</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;通道已关闭&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;v:%#v ok:%#v\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">	<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">f2</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250622171610434.png" 
  alt="image-20250622171610434" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250622171610434.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h3 id="for-range-接收值">for range 接收值</h3>
<p>通常我们会选择使用<code>for range</code>循环从通道中接收值，当通道被关闭后，会在通道内的所有值被接收完毕后会自动退出循环。上面那个示例我们使用<code>for range</code>改写后会很简洁。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">f3</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">	<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">f3</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250622171741656.png" 
  alt="image-20250622171741656" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250622171741656.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p><strong>注意</strong>：目前Go语言中并没有提供一个不对通道进行读取操作就能判断通道是否被关闭的方法。不能简单的通过<code>len(ch)</code>操作来判断通道是否被关闭。</p>
<h3 id="单向通道">单向通道</h3>
<p>在某些场景下我们可能会将通道作为参数在多个任务函数间进行传递，通常我们会选择在不同的任务函数中对通道的使用进行限制，比如限制通道在某个函数中只能执行发送或只能执行接收操作。</p>
<blockquote>
<p><strong>经典的生产者—消费者模型</strong></p>
</blockquote>
<p>想象一下，我们现在有<code>Producer</code>和<code>Consumer</code>两个函数，其中<code>Producer</code>函数会返回一个通道，并且会持续将符合条件的数据发送至该通道，并在发送完成后将该通道关闭。</p>
<p>而<code>Consumer</code>函数的任务是从通道中接收值进行计算，这两个函数之间通过<code>Processer</code>函数返回的通道进行通信。完整的示例代码如下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Producer 返回一个通道
</span></span></span><span class="line"><span class="cl"><span class="c1">// 并持续将符合条件的数据发送至返回的通道中
</span></span></span><span class="line"><span class="cl"><span class="c1">// 数据发送完成后会将返回的通道关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Producer</span><span class="p">()</span> <span class="kd">chan</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个新的goroutine执行发送数据的任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// 任务完成后关闭通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">ch</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Consumer 从通道中接收数据进行计算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Consumer</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">sum</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nf">Producer</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">res</span> <span class="o">:=</span> <span class="nf">Consumer</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="c1">// 25
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>从上面的示例代码中可以看出正常情况下<code>Consumer</code>函数中只会对通道进行接收操作，但是这不代表不可以在<code>Consumer</code>函数中对通道进行发送操作。作为<code>Producer</code>函数的提供者，我们在返回通道的时候可能只希望调用方拿到返回的通道后只能对其进行接收操作。但是我们没有办法阻止在<code>Consumer</code>函数中对通道进行发送操作。</p>
<blockquote>
<p><strong>单向通道</strong></p>
</blockquote>
<p>Go语言中提供了<strong>单向通道</strong>来处理这种需要限制通道只能进行某种操作的情况。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kt">int</span> <span class="c1">// 只接收通道，只能接收不能发送
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">chan</span> <span class="o">&lt;-</span> <span class="kt">int</span> <span class="c1">// 只发送通道，只能发送不能接收
</span></span></span></code></pre></div><p>其中，箭头<code>&lt;-</code>和关键字<code>chan</code>的相对位置表明了当前通道允许的操作，这种限制将在编译阶段进行检测。另外对一个只接收通道执行close也是不允许的，因为默认通道的关闭操作应该由发送方来完成。</p>
<p>我们使用单向通道将上面的示例代码进行如下改造。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Producer2 返回一个接收通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Producer2</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建一个新的goroutine执行发送数据的任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="c1">// 任务完成后关闭通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">ch</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Consumer2 参数为接收通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Consumer2</span><span class="p">(</span><span class="nx">ch</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">sum</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch2</span> <span class="o">:=</span> <span class="nf">Producer2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">	<span class="nx">res2</span> <span class="o">:=</span> <span class="nf">Consumer2</span><span class="p">(</span><span class="nx">ch2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">res2</span><span class="p">)</span> <span class="c1">// 25
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>这一次，<code>Producer</code>函数返回的是一个只接收通道，这就从代码层面限制了该函数返回的通道只能进行接收操作，保证了数据安全。</p>
<p>很多读者看到这个示例可能会觉着这样的限制是多余的，但是试想一下如果<code>Producer</code>函数可以在其他地方被其他人调用，你该如何限制他人不对该通道执行发送操作呢？并且返回限制操作的单向通道也会让代码语义更清晰、更易读。</p>
<p>在函数传参及任何赋值操作中全向通道（正常通道）可以转换为单向通道，但是无法反向转换。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ch3</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">ch3</span> <span class="o">&lt;-</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="nb">close</span><span class="p">(</span><span class="nx">ch3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">Consumer2</span><span class="p">(</span><span class="nx">ch3</span><span class="p">)</span> <span class="c1">// 函数传参时将ch3转为单向通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ch4</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">ch4</span> <span class="o">&lt;-</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ch5</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="c1">// 声明一个只接收通道ch5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">ch5</span> <span class="p">=</span> <span class="nx">ch4</span>          <span class="c1">// 变量赋值时将ch4转为单向通道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">&lt;-</span><span class="nx">ch5</span>
</span></span></code></pre></div><h2 id="select-多路复用">select 多路复用</h2>
<p>在某些场景下我们可能需要<strong>同时从多个通道接收数据</strong>。通道在接收数据时，如果没有数据可以被接收那么当前 goroutine 将会发生阻塞。你也许会写出如下代码尝试使用遍历的方式来实现从多个通道中接收值。</p>
<pre tabindex="0"><code>for{
    // 尝试从ch1接收值
    data, ok := &lt;-ch1
    // 尝试从ch2接收值
    data, ok := &lt;-ch2
    …
}
</code></pre><p>这种方式虽然可以实现从多个通道接收值的需求，但是程序的运行性能会差很多。Go 语言内置了<code>select</code>关键字，使用它可以同时响应多个通道的操作。</p>
<p>Select 的使用方式类似于之前学到的 switch 语句，它也有一系列 case 分支和一个默认的分支。每个 case 分支会对应一个通道的通信（接收或发送）过程。select 会一直等待，直到其中的某个 case 的通信操作完成时，就会执行该 case 分支对应的语句。具体格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">case</span> <span class="nx">data</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">case</span> <span class="nx">ch3</span> <span class="o">&lt;-</span> <span class="mi">10</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//默认操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>Select 语句具有以下特点：</p>
<ul>
<li>可处理一个或多个 channel 的发送/接收操作。</li>
<li>如果多个 case 同时满足，select 会<strong>随机</strong>选择一个执行。</li>
<li>对于没有 case 的 select 会一直阻塞，可用于阻塞 main 函数，防止退出。</li>
</ul>
<p>下面的示例代码能够在终端打印出10以内的奇数，我们借助这个代码片段来看一下 select 的具体使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250630204917713.png" 
  alt="image-20250630204917713" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250630204917713.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>示例中的代码首先是创建了一个缓冲区大小为1的通道 ch，进入 for 循环后：</p>
<ul>
<li>第一次循环时 i = 1，select 语句中包含两个 case 分支，此时由于通道中没有值可以接收，所以<code>x := &lt;-ch</code> 这个 case 分支不满足，而<code>ch &lt;- i</code>这个分支可以执行，会把1发送到通道中，结束本次 for 循环；</li>
<li>第二次 for 循环时，i = 2，由于通道缓冲区已满，所以<code>ch &lt;- i</code>这个分支不满足，而<code>x := &lt;-ch</code>这个分支可以执行，从通道接收值1并赋值给变量 x ，所以会在终端打印出 1；</li>
<li>后续的 for 循环以此类推会依次打印出3、5、7、9。</li>
</ul>
<h2 id="通道的错误-demo">通道的错误 Demo</h2>
<blockquote>
<p><strong>Demo1</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">// demo1 通道误用导致的bug
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">demo1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>   <span class="c1">//等价于 var wg sync.WaitGroup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">task</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 这里假设对接收的数据执行某些操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">task</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>将上述代码编译执行后，匿名函数所在的 goroutine 并不会按照预期在通道被关闭后退出。因为<code>task := &lt;- ch</code>的接收操作在通道被关闭后会一直接收到零值，而不会退出。</p>
<p>此处的接收操作应该使用<code>task, ok := &lt;- ch </code>，通过判断布尔值<code>ok</code>为假时退出；或者使用select 来处理通道。</p>
<blockquote>
<p><strong>Demo2</strong></p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="c1">// demo2 通道误用导致的bug
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">demo2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 这里假设执行一些耗时的操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;job result&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">result</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span> <span class="c1">// 较小的超时时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上述代码片段可能导致 goroutine 泄露（goroutine 并未按预期退出并销毁）。由于 select 命中了超时逻辑，导致通道没有消费者（无接收操作），而其定义的通道为无缓冲通道，因此 goroutine 中的<code>ch &lt;- &quot;job result&quot;</code>操作会一直阻塞，最终导致 goroutine 泄露。</p>
<h2 id="并发安全和锁">并发安全和锁</h2>
<p>有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生<code>竞态问题</code>（数据竞态）。这就好比现实生活中十字路口被各个方向的汽车竞争，还有火车上的卫生间被车厢里的人竞争。</p>
<p>我们用下面的代码演示一个数据竞争的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span> <span class="c1">// 等待组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// add 对全局变量x执行5000次加1操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">add</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">add</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">add</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>我们将上面的代码编译后执行，不出意外每次执行都会输出诸如9537、5865、6527等不同的结果。这是为什么呢？</p>
<p>在上面的示例代码片中，我们开启了两个 goroutine 分别执行 add 函数，这两个 goroutine 在访问和修改全局的<code>x</code>变量时就会存在数据竞争，某个 goroutine 中对全局变量<code>x</code>的修改可能会覆盖掉另一个 goroutine 中的操作，所以导致最后的结果与预期不符。</p>
<h3 id="互斥锁">互斥锁</h3>
<p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用<code>sync</code>包中提供的<code>Mutex</code>类型来实现互斥锁。</p>
<p><code>sync.Mutex</code>提供了两个方法供我们使用。</p>
<p><img 
  src="./2025-0331-01/image-20250630210316403.png" 
  alt="image-20250630210316403" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250630210316403.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>我们在下面的示例代码中使用互斥锁限制每次只有一个 goroutine 才能修改全局变量<code>x</code>，从而修复上面代码中的问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-GO" data-lang="GO"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// sync.Mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">x</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span> <span class="c1">// 等待组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// 互斥锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// add 对全局变量x执行5000次加1操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">add</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">m</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span> <span class="c1">// 修改x前加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="nx">m</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span> <span class="c1">// 改完解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">add</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">add</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>将上面的代码编译后多次执行，每一次都会得到预期中的结果——10000。</p>
<p>使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。</p>
<h3 id="读写互斥">读写互斥</h3>
<p>互斥锁是完全互斥的，但是实际上有很多场景是读多写少的，当我们并发的去读取一个资源而不涉及资源修改的时候是没有必要加互斥锁的，这种场景下使用读写锁是更好的一种选择。</p>
<p>读写锁在 Go 语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。<code>sync.RWMutex</code>提供了以下5个方法。</p>
<p><img 
  src="./2025-0331-01/image-20250630215830178.png" 
  alt="image-20250630215830178" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250630215830178.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>读写锁分为两种：读锁和写锁。当一个 goroutine 获取到 <strong>读锁</strong>：</p>
<ul>
<li>其他 goroutine 也可以继续拿读锁，大家一起读，不会冲突。</li>
<li>但其他 goroutine 不能拿写锁，写操作必须等所有读操作完成。</li>
</ul>
<p>就像是多个人看一本书没问题，但只要有人在看（读锁），就不能有改内容（写锁）</p>
<p>当一个 goroutine 拿到了 <strong>写锁</strong>：</p>
<ul>
<li>其他 goroutine 无论是读还是写，都得等！</li>
<li>也就是说，写的时候是不能有别的读或写操作的。</li>
</ul>
<p>有人正在改这本书（写锁），其他人无论是想看（读锁）还是也想改（写锁）都要排队等他改完。</p>
<p>举个实际的例子：</p>
<ul>
<li>图书馆读者：可以同时看书</li>
<li>图书馆管理员：可修改上架的书，只能一个人干，其他人必须等他干完</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bookShelf</span> <span class="p">=</span> <span class="s">&#34;《Go语言圣经》&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rwLock</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">reader</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">rwLock</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span> <span class="c1">// 获取读锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;📖 读者 %d 正在看书：《%s》\n&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">bookShelf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">// 模拟看书时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;✅ 读者 %d 看完了。\n&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rwLock</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span> <span class="c1">// 释放读锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">writer</span><span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;🛠️ 管理员准备更新书架...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rwLock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span> <span class="c1">// 获取写锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;🚧 管理员正在修改书架上的书...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bookShelf</span> <span class="p">=</span> <span class="s">&#34;《Go并发编程实战》&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span> <span class="c1">// 模拟修改时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;✅ 管理员修改完成，书架更新完毕。&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rwLock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span> <span class="c1">// 释放写锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 前两个读者同时看书
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">reader</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">reader</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span> <span class="c1">// 或用 wg.Wait() 等前两个读者拿到锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 写操作（修改书架）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">writer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span> <span class="c1">// 或用 wg.Wait() 等写锁卡住下面的读者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 后两个读者要等待管理员完成修改
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">reader</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">reader</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="syncwaitgroup">sync.WaitGroup</h3>
<p>前面我们已经了解过 sync.WaitGroup，在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p>
<p><img 
  src="./2025-0331-01/image-20250706104841671.png" 
  alt="image-20250706104841671" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250706104841671.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 Done 方法将计数器减1。通过调用 Wait 来等待并发任务执行完，当计数器值为 0 时，表示所有并发任务已经完成。</p>
<p>需要注意<code>sync.WaitGroup</code>是一个结构体，进行参数传递的时候要传递指针。</p>
<h3 id="synconce">sync.Once</h3>
<p>在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。</p>
<p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案——<code>sync.Once</code>，<code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span>
</span></span></code></pre></div><p>我们来举个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">initConfig</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;📦 配置文件只加载一次&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">id</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">initConfig</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;👷 工人 %d 开始工作\n&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 启动多个并发 goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img 
  src="./2025-0331-01/image-20250706142436577.png" 
  alt="image-20250706142436577" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250706142436577.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p><strong>注意</strong>：<code>sync.Once.Do(f)</code> 这个方法的参数 <code>f</code> 是一个 <strong>没有参数、也没有返回值的函数</strong>，如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</p>
<p>❌ 错误示例（不能这么写）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">initConfig</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;加载配置文件：&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">initConfig</span><span class="p">)</span> <span class="c1">// 错！initConfig 需要参数，Do 接受的必须是 func()
</span></span></span></code></pre></div><p>✅ 正确做法：使用闭包</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">initConfig</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;加载配置文件：&#34;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">path</span> <span class="o">:=</span> <span class="s">&#34;/etc/config.yaml&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">initConfig</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>这里通过 <strong>闭包</strong> 把 <code>path</code> 变量 “包进去”，然后传给 <code>Do()</code> 一个不带参数的匿名函数。</p>
<h3 id="syncmap">sync.Map</h3>
<p>Go 语言中内置的 map 不是并发安全的，请看下面这段示例代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strconv&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">set</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">key</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nf">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;k=:%v,v:=%v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nf">get</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>将上面的代码编译后执行，会报出<code>fatal error: concurrent map writes</code>错误。我们不能在多个 goroutine 中并发对内置的 map 进行读写操作，否则会存在数据竞争问题。</p>
<p>像这种场景下就需要为 map 加锁来保证并发的安全性了，Go语言的 sync 包中提供了一个开箱即用的并发安全版 map——<code>sync.Map</code>。开箱即用表示其不用像内置的 map 一样使用 make 函数初始化就能直接使用。</p>
<p>sync.Map 内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。如下：</p>
<p><img 
  src="./2025-0331-01/image-20250727151746055.png" 
  alt="image-20250727151746055" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250727151746055.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>下面的代码示例演示了并发读写 sync.Map ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;strconv&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 并发安全的map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 对m执行20个并发的读写操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">key</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>         <span class="c1">// 存储key-value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">value</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="c1">// 根据key取值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;k=:%v,v:=%v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="原子操作">原子操作</h3>
<p>如果让我用一句话来说明什么是原子操作，那就是：<strong>原子操作是变量级别的互斥锁。</strong> 简单来说，就是同一时刻，只能有一个 CPU 对变量进行读或写。 当我们想要对某个<strong>变量</strong>做并发安全的修改，除了使用官方提供的 <code>Mutex</code>，还可以使用 <code>sync/atomic</code> 包的原子操作， 它能够保证对变量的读取或修改期间不被其他的协程所影响。</p>
<p>我们可以用下图来表示：</p>
<p><img 
  src="./2025-0331-01/image-20250727153745319.png" 
  alt="image-20250727153745319" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250727153745319.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<p>说明：在上图中，我们有三个 CPU 逻辑核，其中 CPU 1 正在对变量 <code>v</code> 做原子操作，这个时候 CPU 2 和 CPU 3 不能对 <code>v</code> 做任何操作， 在 CPU 1 操作完成后，CPU 2 和 CPU 3 可以获取到 <code>v</code> 的最新值。</p>
<p>从这个角度看，我们可以把 <code>sync/atomic</code> 包中的原子操作看成是变量级别的互斥锁。 就是说，在 go 中，当一个协程对变量做原子操作时，其他协程不能对这个变量做任何操作，直到这个协程操作完成。</p>
<p>原子操作的使用场景：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">TestAtomic</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">sum</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 启动 1000 个协程，每个协程对 sum 做加法操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sum</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 等待所有的协程都执行完毕
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span> <span class="c1">// 这里输出多少呢？
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>我们可以在自己的电脑上运行一下这段代码，看看输出的结果是多少。 不出意外的话，应该每次可能都不一样，而且应该也不是 1000，这是为什么呢？</p>
<p>这是因为，CPU 在对 <code>sum</code> 做加法的时候，需要先将 <code>sum</code> 目前的值读取到 CPU 的寄存器中，然后再进行加法操作，最后再写回到内存中。 如果有两个 CPU 同时取了 <code>sum</code> 的值，然后都进行了加法操作，然后都再写回到内存中，那么就会导致 <code>sum</code> 的值被覆盖，从而导致结果不正确。</p>
<p>举个例子，目前内存中的 <code>sum</code> 为 1，然后两个 CPU 同时取了这个 1 来做加法，然后都得到了结果 2， 然后这两个 CPU 将各自的计算结果写回到内存中，那么内存中的 <code>sum</code> 就变成了 2，而不是 3。</p>
<p>在这种场景下，我们可以使用原子操作来实现并发安全的加法操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">TestAtomic1</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 将 sum 的类型改成 int32，因为原子操作只能针对 int32、int64、uint32、uint64、uintptr 这几种类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">sum</span> <span class="kt">int32</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 启动 1000 个协程，每个协程对 sum 做加法操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 将 sum++ 改成下面这样
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sum</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span> <span class="c1">// 输出 1000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>在上面这个例子中，我们每次执行都能得到 1000 这个结果。</p>
<p><strong>所以很多需要对变量做并发读写的地方，我们都可以考虑一下，是否可以使用原子操作来实现并发安全的操作（而不是使用互斥锁，互斥锁效率相比原子操作要低一些）。</strong></p>
<p>原子操作的使用场景也是和互斥锁类似的，但是不一样的是，我们的锁粒度只是一个变量而已。也就是说，当我们不允许多个 CPU 同时对变量进行读写的时候（保证变量同一时刻只能一个 CPU 操作），就可以使用原子操作。</p>
<p>原子操作的特征：</p>
<ul>
<li>不会被中断：原子操作是一个不可分割的操作，要么全部执行，要么全部不执行，不会出现中间状态。这是保证原子性的基本前提。同时，<strong>原子操作过程中不会有上下文切换的过程。</strong></li>
<li>操作对象是共享变量：原子操作通常是对共享变量进行的，也就是说，多个协程可以同时访问这个变量，因此需要采用原子操作来保证数据的一致性和正确性。</li>
<li>并发安全：原子操作是并发安全的，可以保证多个协程同时进行操作时不会出现数据竞争问题（虽然说是同时，但是实际上在操作那个变量的时候是互斥的）。</li>
<li>无需加锁：原子操作不需要使用互斥锁来保证数据的一致性和正确性，因此可以避免互斥锁的使用带来的性能损失。</li>
<li>适用场景比较局限：原子操作适用于操作单个变量，如果需要同时并发读写多个变量，可能需要考虑使用互斥锁。</li>
</ul>
<p>在 go 中，主要有以下几种原子操作：<code>Add</code>、<code>CompareAndSwap</code>、<code>Load</code>、<code>Store</code>、<code>Swap</code>。</p>
<p><img 
  src="./2025-0331-01/image-20250727155631146.png" 
  alt="image-20250727155631146" 
   
  class="custom-image-class"
  srcset="./2025-0331-01/image-20250727155631146.png 1.25x"
 />


<script>
function improveImage() {
    

    
    const images = document.querySelectorAll('img');

    images.forEach((item) => {
        
        let srcset = item.getAttribute('srcset');
        if (srcset) {
            let imageName = srcset.match(/image-(\d+\.(png|jpg|jpeg|gif))\s(\d+(\.\d+)?x)/i); 
            if (imageName) {
                item.setAttribute('srcset', imageName[0]);
            }
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    improveImage();
});
</script></p>
<h1 id="处理并发错误">处理并发错误</h1>
<p>我们可以在Go语言中十分便捷地开启goroutine去并发地执行任务，但是如何有效的处理并发过程中的错误则是一个很棘手的问题，这里介绍了一些处理并发错误的方法。</p>
<h2 id="recover-goroutine-中的-panic">recover goroutine 中的 panic</h2>
<p>我们知道可以在代码中使用 recover 来会恢复程序中意想不到的 panic，而 panic 只会触发当前 goroutine 中的 defer 操作。</p>
<p>例如在下面的示例代码中，无法在 main 函数中 recover 另一个goroutine中引发的 panic。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"></code></pre></div><h1 id="拓展go-的一些命名规范">拓展：Go 的一些命名规范</h1>
</article>
              </div>

              
            </div>
          </div>
        </div>
      </div>

      <div class="pagination-nav">
        <div class="pagination-button next-post">
          
          <div>«&nbsp;</div><a class="pagination-link link-reverse" href="https://rvnox.github.io/post/2025-0414-01/"> kubernetes 介绍</a>
          
        </div>
        
        <div class="pagination-button previous-post">
          
          <a class="pagination-link link-reverse" href="https://rvnox.github.io/post/2025-0309-01/">Grafana 变量&nbsp;</a><div> »</div>
          
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://rvnox.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://rvnox.github.io/css/toc.css' />


  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://rvnox.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://rvnox.github.io/js/github-style.js"></script>

<script src="https://rvnox.github.io/js/mark.es6.min.js"></script>







</html>